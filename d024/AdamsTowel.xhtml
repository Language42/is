<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="https://l42.is/css/style.css" media="all"/>
    <script src="https://l42.is/js/ace.js"></script>
    <script src="https://l42.is/js/utils.js"></script>
    <link rel="shortcut icon" href="https://l42.is/css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="https://www.googletagmanager.com/gtag/js?id=G-M0E4M0XH2Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-M0E4M0XH2Z');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-212820693-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-212820693-1');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=AW-10810288706"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'AW-10810288706');
    </script>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='https://l42.is/css/logoBlue.png' alt='42' width='120' height='120'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>

<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90">Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="#AdamsTowel"> AdamsTowel </a></li>
 <li><a href="#Collection"> Collection </a></li>
 <li><a href="#Message"> Message </a></li>
</ol>
</div></div><div class="finishFloat"></div></div>

</p><p id="AdamsTowel">
</p><div style="break-after:page"></div><h1> AdamsTowel </h1> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> is the most developed 42 towel, and it is a good starting point for varius 
forms of towel staining and embroidery.
Refer to the <a href="../tutorial_01Basics.xhtml">tutorial</a>
for more informations.
</p><h2> Importing process and example usage </h2> <p>
<pre class="l42Big"><![CDATA[
reuse[L42.is/AdamsTowel]
..
Main = Debug(S"Hello world")
]]></pre>

</p><h2> Overview </h2> <p>
<pre class="l42BigFolded"><![CDATA[
@Public AbstractTowel={
  }
@Public Bool={
  [HasToS]
  //class methods:
  #apply(string)                     class method This #apply(S string)=(..)
  false()                            class method This false()=(..)
  true()                             class method This true()=(..)
  //imm methods:
  #bang0()                           method This #bang0()=(..)
  #bangequal0(that)                  method This #bangequal0(This that)=(..)
  #checkTrue()                       method Void #checkTrue()[Void]native{..}=(..)
  #equalequal0(that)                 method This #equalequal0(This that)=(..)
  #if()                              method This #if()=(..)
  and(that)                          method This and(This that)native{..}=(..)
  not()                              method This not()native{..}=(..)
  or(that)                           method This or(This that)native{..}=(..)
  //read methods:
  readEquality(that)                 read method This readEquality(read This that)native{..}=(..)
  toS()                              read method S toS()native{..}=(..)
  List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method This1 #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method This1 equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method This1 #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method This1 #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method This1 #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method This1 allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method This1 contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method This1 isEmpty()native{..}=(..)
    isMutVal(that)                     read method This1 isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method This1 readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @AbstractTowel{
    bool
    }
  }
@Public Break={
  #apply()                           class method Void #apply()[Void]=(..)
  #apply(that)                       class method Void #apply(Void that)[Void]=(..)
  @AbstractTowel{
    break
    }
  }
@Public Cache={
  #$stopCacheEager()                 class method Void #$stopCacheEager()=(..)
  Call={
    #colon0(l)                         @Public class method Trait #colon0(class Trait.Lifted l)[Fail]=(..)
    #colon0(t)                         @Public class method Trait #colon0(Trait t)[Fail]=(..)
    #colon0(that)                      @Public class method Library #colon0(Library that)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method class This1 #apply()=(..)
      }
    @Public Fail={
      [HasToS, Message, Message.Guard]
      //class methods:
      #apply()                           class method This #apply()=(..)
      #apply(that)                       class method mut This #apply(S that)native{..}=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
      //read methods:
      text()                             read method S text()native{..}=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      text(that)                         mut method Void text(S that)native{..}=(..)
      }
    @{
      callCache
      }
    }
  Clear={
    @{
      invalidateCache
      }
    }
  Eager={
    @{
      eagerCache
      }
    }
  ForkJoin={
    @{
      forkJoin
      }
    }
  Lazy={
    @{
      lazyCache
      }
    }
  LazyRead={
    @{
      lazyReadCache
      }
    }
  Now={
    @{
      readNowCache
      }
    }
  @AbstractTowel{
    cache
    }
  }
@Public Class={
  #colon0(library)                   class method Library #colon0(Library library)[IncoherentClass]=(..)
  #colon0(lifted)                    class method Library #colon0(class Trait.Lifted lifted)[IncoherentClass]=(..)
  #colon0(that)                      class method Library #colon0(Trait that)[IncoherentClass]=(..)
  ClassOperators={
    #apply()                           class method class This1 #apply()=(..)
    }
  IncoherentClass={
    [Message, HasToS, Data.Fail, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  Relax={
    #colon0(lifted)                    class method Library #colon0(class Trait.Lifted lifted)=(..)
    #colon0(that)                      class method Library #colon0(Trait that)=(..)
    ClassOperators={
      #apply()                           class method class This1 #apply()=(..)
      }
    }
  @AbstractTowel{
    class
    }
  }
@Public Collection={
  linkedList(that)                   @Public class method Library linkedList(class Any that)=(..)
  linkedListTrait()                  @Public class method Trait linkedListTrait()=(..)
  list(that)                         @Public class method Library list(class Any that)=(..)
  listTrait()                        @Public class method Trait listTrait()=(..)
  map(key, val)                      @Public class method Library map(class Any key, class Any val)=(..)
  mapTrait()                         @Public class method Trait mapTrait()=(..)
  matrix(that, row, col)             @Public class method Library matrix(class Any that, I row, I col)[Class.IncoherentClass, Data.Close.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash, NoElementInOpt]=(..)
  matrixTrait()                      @Public class method Trait matrixTrait()=(..)
  maxSize()                          @Public@Cache.Lazy class method I maxSize()native{..}=(..)
  optional(that)                     @Public class method Library optional(class Any that)=(..)
  optionalTrait()                    @Public class method Trait optionalTrait()=(..)
  set(that)                          @Public class method Library set(class Any that)=(..)
  setTrait()                         @Public class method Trait setTrait()=(..)
  @Public AnyToS={
    #apply(that)                       class method S #apply(read Any that)=(..)
    escape(that)                       class method S escape(S that)=(..)
    }
  @Public Dimensions={
    [HasToS]
    //class methods:
    #apply(row, col)                   class method This #apply(I row, I col)=(..)
    #immK(row, col)                    class method This #immK(I row, I col)=(..)
    invariant(row, col)                class method Void invariant(I row, I col)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    norm()                             method This norm()=(..)
    tot()                              method I tot()=(..)
    with(col)                          method This with(I col)=(..)
    with(row)                          method This with(I row)=(..)
    //read methods:
    col()                              read method I col()=(..)
    immClone()                         read method This immClone()=(..)
    invariant()                        @Cache.Now read method Void invariant()native{..}=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    row()                              read method I row()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    capsuleClone()                     mut method capsule This capsuleClone()=(..)
    }
  @Public ElementNotImm={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public ElementNotMut={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public Enum={
    #colon0(that)                      class method Library #colon0(Library that)[Fail]=(..)
    #colon0(trait)                     class method Trait #colon0(Trait trait)[Fail]=(..)
    ClassOperators={
      #apply()                           class method class This1 #apply()=(..)
      }
    Fail={
      [Message, HasToS, Message.Guard]
      //class methods:
      #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
      #apply(that)                       class method mut This #apply(S that)=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
      with(cause)                        method This with(Message cause)=(..)
      //read methods:
      cause()                            read method Message.OptMessage cause()=(..)
      text()                             read method S text()=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
      text(that)                         mut method Void text(S that)=(..)
      }
    TraitCacheVals={
      [Trait.Lifted]
      #apply()                           class method Trait #apply()=(..)
      #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
      #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      code()                             class method Library code()=(..)
      info()                             class method Info info()=(..)
      resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
      ClassOperators={
        #apply()                           class method Trait #apply()=(..)
        }
      }
    TraitEnumBase={
      [Trait.Lifted]
      #apply()                           class method Trait #apply()=(..)
      #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
      #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      code()                             class method Library code()=(..)
      info()                             class method Info info()=(..)
      resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
      ClassOperators={
        #apply()                           class method Trait #apply()=(..)
        }
      }
    TraitEnumStep={
      [Trait.Lifted]
      #apply()                           class method Trait #apply()=(..)
      #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
      #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
      code()                             class method Library code()=(..)
      info()                             class method Info info()=(..)
      resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
      ClassOperators={
        #apply()                           class method Trait #apply()=(..)
        }
      }
    }
  @Public IterationIncomplete={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  @Public IteratorCompose={
    //class methods:
    #apply(that)                       class method This #apply(Bool that)=(..)
    canContinue()                      class method This canContinue()=(..)
    canStop()                          class method This canStop()=(..)
    cut(that)                          class method This cut(Bool that)=(..)
    cutDefault(that)                   class method This cutDefault(Bool that)=(..)
    default(that)                      class method This default(Bool that)=(..)
    mustContinue()                     class method This mustContinue()=(..)
    mustStop()                         class method This mustStop()=(..)
    zero()                             class method This zero()=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    #gt0(that)                         method Bool #gt0(This that)=(..)
    #if()                              method Bool #if()=(..)
    #itAdd(that)                       method This #itAdd(This that)=(..)
    #lt0(that)                         method Bool #lt0(This that)native{..}=(..)
    #minus0(that)                      method This #minus0(This that)native{..}=(..)
    #times0(that)                      method This #times0(This that)native{..}=(..)
    isZero()                           method Bool isZero()=(..)
    pred()                             method This pred()native{..}=(..)
    signum()                           method This signum()native{..}=(..)
    succ()                             method This succ()native{..}=(..)
    //read methods:
    readEquality(that)                 read method Bool readEquality(read This that)native{..}=(..)
    }
  @Public NoElementInOpt={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public OperationUndefinedOnEmpty={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  @Public OutOfBounds={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public View={
    [HasToS]
    //class methods:
    #apply(that)                       @Public class method This #apply(class Any that)=(..)
    //imm methods:
    #toLibrary()                       @Public method Library #toLibrary()[Data.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
    cut()                              @Public method This cut()=(..)
    defaultMut()                       @Public method This defaultMut()=(..)
    defaultRead()                      @Public method This defaultRead()=(..)
    more()                             @Public method This more()=(..)
    moreMut()                          @Public method This moreMut()=(..)
    //read methods:
    toS()                              read method S toS()=(..)
    }
  @AbstractTowel{
    collection
    }
  }
@Public Data={
  //class methods:
  #apply()                           @Public class method This #apply()=(..)
  #apply(string)                     @Public class method This #apply(S string)=(..)
  #apply(that)                       @Public class method This #apply(Name that)=(..)
  #apply(that, autoNorm)             @Public class method This #apply(Name that, Bool autoNorm)=(..)
  #apply(that, check, autoNorm)      @Public class method This #apply(Name that, Bool check, Bool autoNorm)=(..)
  #from(stringLiteral)               @Public class method This #from(S.StringBuilder stringLiteral)=(..)
  addCapsuleClone()                  @Public class method Trait addCapsuleClone()=(..)
  addEqOp()                          @Public class method Trait addEqOp()=(..)
  addHasToS()                        @Public class method Trait addHasToS()=(..)
  addImmClone()                      @Public class method Trait addImmClone()=(..)
  addImmNorm()                       @Public class method Trait addImmNorm()=(..)
  addNEqOp()                         @Public class method Trait addNEqOp()=(..)
  addReadEqOp()                      @Public class method Trait addReadEqOp()=(..)
  checkCoherent(that)                @Public class method Void checkCoherent(Library that)[Class.IncoherentClass]=(..)
  //imm methods:
  #colon0(lib)                       @Public method Library #colon0(Library lib)[Fail]=(..)
  #colon0(that)                      @Public method Trait #colon0(Trait that)[Fail]=(..)
  optionallyApply(that, acc)         @Public method Trait optionallyApply(Trait that, Trait acc)=(..)
  @Public AddConstructors={
    //class methods:
    #apply(string)                     @Public class method This #apply(S string)=(..)
    #apply(that, noFwd)                @Public class method This #apply(Name that, Bool noFwd)=(..)
    #from(stringLiteral)               @Public class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #colon0(l)                         @Public method Trait #colon0(class Trait.Lifted l)[Fail]=(..)
    #colon0(t)                         @Public method Trait #colon0(Trait t)[Fail]=(..)
    #colon0(that)                      @Public method Library #colon0(Library that)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [HasToS, Message, Message.Guard, Fail]
      //class methods:
      #apply()                           class method This #apply()=(..)
      #apply(that)                       class method mut This #apply(S that)native{..}=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
      //read methods:
      text()                             read method S text()native{..}=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      text(that)                         mut method Void text(S that)native{..}=(..)
      }
    }
  @Public AddList={
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #colon0(that)                      @Public method Trait #colon0(Trait that)[Trait.ClassClash, Trait.MethodClash]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    }
  @Public AddOpt={
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #colon0(that)                      @Public method Trait #colon0(Trait that)[Trait.ClassClash, Trait.MethodClash]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    }
  @Public AddSet={
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #colon0(that)                      @Public method Trait #colon0(Trait that)[Trait.ClassClash, Trait.MethodClash]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    }
  @Public ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  @Public Close={
    //class methods:
    #apply(that, autoNorm)             @Public class method This #apply(Name that, Bool autoNorm)=(..)
    all(that, autoNorm)                @Public class method Trait all(Trait that, Bool autoNorm)[Fail]=(..)
    //imm methods:
    #colon0(l)                         @Public method Trait #colon0(class Trait.Lifted l)[Fail]=(..)
    #colon0(t)                         @Public method Trait #colon0(Trait t)[Fail]=(..)
    #colon0(that)                      @Public method Library #colon0(Library that)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [HasToS, Message, Message.Guard, Fail]
      //class methods:
      #apply()                           class method This #apply()=(..)
      #apply(that)                       class method mut This #apply(S that)native{..}=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
      //read methods:
      text()                             read method S text()native{..}=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      text(that)                         mut method Void text(S that)native{..}=(..)
      }
    }
  @Public Defaults={
    //class methods:
    #apply(that)                       @Public class method This #apply(Name that)=(..)
    //imm methods:
    #colon0(l)                         @Public method Trait #colon0(class Trait.Lifted l)[Fail]=(..)
    #colon0(t)                         @Public method Trait #colon0(Trait t)[Fail]=(..)
    #colon0(that)                      @Public method Library #colon0(Library that)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [HasToS, Message, Message.Guard, Fail]
      //class methods:
      #apply()                           class method This #apply()=(..)
      #apply(that)                       class method mut This #apply(S that)native{..}=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
      //read methods:
      text()                             read method S text()native{..}=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      text(that)                         mut method Void text(S that)native{..}=(..)
      }
    @{
      applyDefaults
      }
    }
  @Public Fail={
    interface[Message.Guard, Message, HasToS]
    //class methods:
    #apply(that)                       class method mut Message #apply(S that)
    #from(stringLiteral)               class method Message #from(S.StringBuilder stringLiteral)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)
    //read methods:
    text()                             read method S text()
    toS()                              read method S toS()
    //mut methods:
    text(that)                         mut method Void text(S that)
    }
  @Public Relax={
    #apply()                           class method This1 #apply()=(..)
    #apply(string)                     class method This1 #apply(S string)=(..)
    #apply(that)                       class method This1 #apply(Name that)=(..)
    #apply(that, autoNorm)             class method This1 #apply(Name that, Bool autoNorm)=(..)
    #from(stringLiteral)               class method This1 #from(S.StringBuilder stringLiteral)=(..)
    ClassOperators={
      #apply()                           class method This2 #apply()=(..)
      }
    }
  @Public Wither={
    //class methods:
    #apply(that)                       @Public class method This #apply(Name that)=(..)
    //imm methods:
    #colon0(l)                         @Public method Trait #colon0(class Trait.Lifted l)[Fail]=(..)
    #colon0(t)                         @Public method Trait #colon0(Trait t)[Fail]=(..)
    #colon0(that)                      @Public method Library #colon0(Library that)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [HasToS, Message, Message.Guard, Fail]
      //class methods:
      #apply()                           class method This #apply()=(..)
      #apply(that)                       class method mut This #apply(S that)native{..}=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
      //read methods:
      text()                             read method S text()native{..}=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      text(that)                         mut method Void text(S that)native{..}=(..)
      }
    }
  @AbstractTowel{
    data
    }
  }
@Public Debug={
  #apply(that)                       @Public class method Void #apply(read HasToS that)=(..)
  @AbstractTowel{
    debug
    }
  }
@Public Decorator={
  //class methods:
  #apply()                           @Public class method This #apply()=(..)
  //imm methods:
  #apply(trait)                      @Public method Trait #apply(Trait trait)[Message.Guard]=(..)
  #colon0(lib)                       @Public method Library #colon0(Library lib)[Fail]=(..)
  #colon0(trait)                     @Public method Trait #colon0(Trait trait)[Fail]=(..)
  @Public ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  @Public Fail={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  @Public WithArgs={
    //class methods:
    #apply()                           @Public class method This #apply()=(..)
    //imm methods:
    #apply(trait)                      @Public method Trait #apply(Trait trait)[Message.Guard]=(..)
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Fail]=(..)
    #colon0(trait)                     @Public method Trait #colon0(Trait trait)[Fail]=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [Message, HasToS, Message.Guard]
      //class methods:
      #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
      #apply(that)                       class method mut This #apply(S that)=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
      with(cause)                        method This with(Message cause)=(..)
      //read methods:
      cause()                            read method Message.OptMessage cause()=(..)
      text()                             read method S text()=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
      text(that)                         mut method Void text(S that)=(..)
      }
    }
  @AbstractTowel{
    decorator
    }
  }
@Public Double={
  [HasToS, Math.Numeric]
  //class methods:
  #apply(num)                        class method This #apply(Num num)native{..}=(..)
  #apply(string)                     class method This #apply(S string)=(..)
  #apply(that)                       class method This #apply(Math.Numeric that)=(..)
  #from(stringLiteral)               @Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
  zero()                             class method This zero()=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #divide0(that)                     method This #divide0(This that)native{..}=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  #gt0(that)                         method Bool #gt0(This that)=(..)
  #gtequal0(that)                    method Bool #gtequal0(This that)=(..)
  #lt0(that)                         method Bool #lt0(This that)native{..}=(..)
  #ltequal0(that)                    method Bool #ltequal0(This that)native{..}=(..)
  #minus0(that)                      method This #minus0(This that)native{..}=(..)
  #plus0(that)                       method This #plus0(This that)native{..}=(..)
  #times0(that)                      method This #times0(This that)native{..}=(..)
  acc()                              method mut Acc acc()=(..)
  atan2(that)                        method This atan2(This that)native{..}=(..)
  ceil()                             method I ceil()native{..}=(..)
  ceilLong()                         method Math.Long ceilLong()native{..}=(..)
  clamp(that, max)                   method This clamp(This that, This max)=(..)
  cos()                              method This cos()native{..}=(..)
  floor()                            method I floor()native{..}=(..)
  floorLong()                        method Math.Long floorLong()native{..}=(..)
  isInRange(that, to)                method Bool isInRange(This that, This to)=(..)
  max(that)                          method This max(This that)=(..)
  min(that)                          method This min(This that)=(..)
  pow(exp)                           method This pow(This exp)native{..}=(..)
  pred()                             @{
    Meta-programming friendly method.
    The predecessor operation. Simply subtracts 1
    }method This pred()native{..}=(..)
  round()                            method I round()native{..}=(..)
  roundLong()                        method Math.Long roundLong()native{..}=(..)
  sin()                              method This sin()native{..}=(..)
  succ()                             @{
    Meta-programming friendly method.
    The successor operation. Simply adds 1
    }method This succ()native{..}=(..)
  tan()                              method This tan()native{..}=(..)
  toDouble()                         method This toDouble()=(..)
  toI()                              method I toI()native{..}=(..)
  toLong()                           method Math.Long toLong()native{..}=(..)
  toNum()                            method Num toNum()=(..)
  //read methods:
  readEquality(that)                 read method Bool readEquality(read This that)native{..}=(..)
  toS()                              read method S toS()native{..}=(..)
  Acc={
    //class methods:
    #apply(val)                        class method mut This #apply(This1 val)=(..)
    //read methods:
    val()                              read method This1 val()=(..)
    //mut methods:
    #apply(that)                       mut method This1 #apply(Void that)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    addIf(that)                        mut method Void addIf(Bool that)=(..)
    addOne()                           mut method Void addOne()=(..)
    divide(that)                       mut method Void divide(This1 that)=(..)
    times(that)                        mut method Void times(This1 that)=(..)
    val(that)                          mut method Void val(This1 that)=(..)
    }
  List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @AbstractTowel{
    double
    }
  }
@Public HasToS={
  interface
  toS()                              read method S toS()
  Raw={
    interface[This1]
    toS()                              read method S toS()
    }
  @AbstractTowel{
    hasToS
    }
  }
@Public I={
  [HasToS, Math.Numeric]
  //class methods:
  #apply(num)                        @{
    Conversion method.
    Rounds the parameter (floor) to the nearest int32.
    }class method This #apply(Num num)native{..}=(..)
  #apply(string)                     @{
    Conversion method.
    Parse the string a produce the corresponding number.
    throws error @S.ParseError if the string is not a valid int32.
    }class method This #apply(S string)=(..)
  #apply(that)                       class method This #apply(Math.Numeric that)=(..)
  #from(stringLiteral)               @Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
  zero()                             @{
    Meta-programming friendly method.
    The constant zero.
    }class method This zero()=(..)
  //imm methods:
  #bangequal0(that)                  @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns false iff this = that, in the common mathematical interpretation.
    }method Bool #bangequal0(This that)=(..)
  #divide0(that)                     @{
    Optimized Signed Modular Arithmetic Operation.
    Signed Int32 integer division, beware of lost precision because of reminders.
    }method This #divide0(This that)native{..}=(..)
  #equalequal0(that)                 @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this = that, in the common mathematical interpretation.
    }method Bool #equalequal0(This that)=(..)
  #gt0(that)                         @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this > that, in the common mathematical interpretation.
    }method Bool #gt0(This that)=(..)
  #gtequal0(that)                    @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this >= that, in the common mathematical interpretation.
    }method Bool #gtequal0(This that)=(..)
  #lt0(that)                         @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this < that, in the common mathematical interpretation.
    }method Bool #lt0(This that)native{..}=(..)
  #ltequal0(that)                    @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this <= that, in the common mathematical interpretation.
    }method Bool #ltequal0(This that)native{..}=(..)
  #minus0(that)                      @{
    Optimized Signed Modular Arithmetic Operation.
    Signed Int32 subtraction, beware of overflows/underflows.
    }method This #minus0(This that)native{..}=(..)
  #plus0(that)                       @{
    Optimized Signed Modular Arithmetic Operation.
    Signed Int32 addition, beware of overflows/underflows.
    }method This #plus0(This that)native{..}=(..)
  #times0(that)                      @{
    Optimized Signed Modular Arithmetic Operation.
    Signed Int32 multiplication, beware of overflows/underflows.
    }method This #times0(This that)native{..}=(..)
  acc()                              method mut Acc acc()=(..)
  ceil()                             @{
    Meta-programming friendly method.
    For this class it just returns the receiver.
    }method This ceil()=(..)
  clamp(that, max)                   method This clamp(This that, This max)=(..)
  clamp(that, to)                    method This clamp(This that, This to)=(..)
  floor()                            @{
    Meta-programming friendly method.
    For this class it just returns the receiver.
    }method This floor()=(..)
  isInRange(that, to)                method Bool isInRange(This that, This to)=(..)
  max(that)                          method This max(This that)=(..)
  min(that)                          method This min(This that)=(..)
  mod(that)                          @{
    Optimized Signed Modular Arithmetic Operation.
    Signed Int32 integer reminder. a - ((a/b)*b) = a.mod(b)
    }method This mod(This that)native{..}=(..)
  pred()                             @{
    Meta-programming friendly method.
    The predecessor operation.
    }method This pred()native{..}=(..)
  round()                            @{
    Meta-programming friendly method.
    For this class it just returns the receiver.
    }method This round()=(..)
  signum()                           @{
    Optimized Signed Modular Arithmetic Operation.
    This operation returns -1, 0 or 1 if the receiver is negative, zero or positive, respectivelly.
    }method This signum()native{..}=(..)
  succ()                             @{
    Meta-programming friendly method.
    The successor operation.
    }method This succ()native{..}=(..)
  toDouble()                         @{
    Conversion method.
    Turns the receiver into its nearest double representation.
    }method Double toDouble()native{..}=(..)
  toI()                              @{
    Meta-programming friendly method.
    For this class it just returns the receiver.
    }method This toI()=(..)
  toLong()                           @{
    Conversion method.
    Turns the receiver into its int64 representation.
    }method Math.Long toLong()native{..}=(..)
  toNum()                            @{
    Conversion method.
    Turns the receiver into its arbitrary precision rational representation.
    }method Num toNum()=(..)
  toNum(denominator)                 @{
    Conversion method.
    Result = receiver/denominator.
    }method Num toNum(This denominator)=(..)
  //read methods:
  readEquality(that)                 @{
    Optimized Signed Modular Arithmetic Relation.
    This operation returns true iff this = that, in the common mathematical interpretation.
    }read method Bool readEquality(read This that)native{..}=(..)
  toS()                              read method S toS()native{..}=(..)
  Acc={
    //class methods:
    #apply(val)                        class method mut This #apply(This1 val)=(..)
    //read methods:
    val()                              read method This1 val()=(..)
    //mut methods:
    #apply(that)                       mut method This1 #apply(Void that)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    addIf(that)                        mut method Void addIf(Bool that)=(..)
    addOne()                           mut method Void addOne()=(..)
    divide(that)                       mut method Void divide(This1 that)=(..)
    times(that)                        mut method Void times(This1 that)=(..)
    val(that)                          mut method Void val(This1 that)=(..)
    }
  List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(This1 capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(This1 that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(This1 that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(This1 that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(This1 that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(This1 that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(This1 that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(This1 that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method This1 #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method This1 indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method This1 indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(This1 that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(This1 that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method This1 size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(This1 that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(This1 that)=(..)
    vals(that, to)                     read method read Iterator vals(This1 that, This1 to)=(..)
    vals(to)                           read method read Iterator vals(This1 to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(This1 that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(This1 that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(This1 that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(This1 that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(This1 that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(This1 that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(This1 that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(This1 that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(This1 that, This1 to)=(..)
    #vals(to)                          mut method mut Iterator #vals(This1 to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(This1 that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(This1 that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(This1 that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(This2 start, This2 end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(This2 that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(This2 that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(This2 that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(This2 that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method This2 #startIndex()=(..)
      end()                              read method This2 end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method This2 start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(This2 that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(This2 that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(This2 that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(This2 that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @AbstractTowel{
    size
    }
  }
@Public Info={
  [HasToS]
  //class methods:
  #apply(library)                    @Public class method This #apply(Library library)=(..)
  #apply(that)                       @Public class method This #apply(class Any that)=(..)
  //imm methods:
  #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
  classAny()                         @Public method class Any classAny()=(..)
  hasHiddenImplements()              @Public method Bool hasHiddenImplements()=(..)
  hasOuter()                         @Public method Bool hasOuter()=(..)
  implements()                       @Public method Type.List implements()=(..)
  innerDoc()                         @Public method Doc innerDoc()=(..)
  isBinded()                         @Public method Bool isBinded()=(..)
  isClose()                          @Public method Bool isClose()=(..)
  isCoherent()                       @Public method S isCoherent()=(..)
  isInterface()                      @Public method Bool isInterface()=(..)
  meth(name)                         @{
    If the name has empty path, the method named as name.selector() is returned,
    otherwise the name path and selector are fetched from the root of this.
    }@Public method Method meth(Name name)=(..)
  methods()                          @Public method Method.List methods()=(..)
  msgTitle(text)                     @Public method S msgTitle(S text)=(..)
  nameFromRoot()                     @Public method Name nameFromRoot()=(..)
  nested(name)                       @Public method This nested(Name name)=(..)
  nesteds()                          @Public method List nesteds()=(..)
  outer()                            @Public method This outer()=(..)
  outerDoc()                         @Public method Doc outerDoc()=(..)
  outerName()                        @Public method S outerName()=(..)
  position()                         @Public method S position()=(..)
  root()                             @Public method This root()=(..)
  toFullS()                          @Public method S toFullS()=(..)
  //read methods:
  toS()                              read method S toS()=(..)
  @Public Doc={
    [HasToS]
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    annotatedAs(nested)                @Public method Bool annotatedAs(This1 nested)=(..)
    annotatedAs(that)                  @Public method Bool annotatedAs(class Any that)=(..)
    annotation(nested)                 @Public method Opt annotation(This1 nested)=(..)
    annotation(that)                   @Public method Opt annotation(class Any that)=(..)
    docs()                             @Public method List docs()=(..)
    hasAnnotation()                    @Public method Bool hasAnnotation()=(..)
    info()                             @Public method This1 info()=(..)
    name()                             @Public method Name name()=(..)
    nameFromRoot()                     @Public method Name nameFromRoot()=(..)
    root()                             @Public method This1 root()=(..)
    texts()                            @Public method S.List texts()=(..)
    //read methods:
    toS()                              read method S toS()=(..)
    @Public List={
      [HasToS]
      //class methods:
      #apply()                           class method mut This #apply()=(..)
      #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
      #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
      #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
      #squareBuilder()                   class method mut This #squareBuilder()=(..)
      equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
      //imm methods:
      #bangequal0(that)                  @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #equalequal0(This that)=(..)
      #minus0(right)                     @{
        Wither
        Returns the receiver but without all the elements equal to 'right'
        }method This #minus0(This1 right)=(..)
      #minusminus0(right)                @{
        Wither
        Returns the receiver but without all the elements contained in the list 'right'
        }method This #minusminus0(This right)=(..)
      #plus0(right)                      method This #plus0(This1 right)=(..)
      #plus1(left)                       method This #plus1(This1 left)=(..)
      #plusplus0(right)                  method This #plusplus0(This right)=(..)
      immNorm()                          method This immNorm()=(..)
      with(left)                         method This with(This1 left)=(..)
      with(right)                        method This with(This1 right)=(..)
      with(that, val)                    method This with(I that, This1 val)=(..)
      withAlso(left)                     method This withAlso(This1 left)=(..)
      withAlso(right)                    method This withAlso(This1 right)=(..)
      withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
      without(left)                      @{
        Wither
        Returns the receiver but without the leftmost element equal to 'val'
        }method This without(read This1 left)=(..)
      without(right)                     @{
        Wither
        Returns the receiver but without the rightmost element equal to 'val'
        }method This without(read This1 right)=(..)
      without(that)                      method This without(I that)=(..)
      withoutAll(val)                    @{
        Wither
        Returns the receiver but without all the elements equal to 'val'
        }method This withoutAll(read This1 val)=(..)
      withoutLeft()                      method This withoutLeft()=(..)
      withoutRight()                     method This withoutRight()=(..)
      //read methods:
      #elem#default(that)                read method This1 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #in1(that)                         @{
        Predicate
        True if the element is contained in the List.
        }read method Bool #in1(read This1 that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      allEq(that)                        @{
        Predicate
        returns true if all the elements in 'this' are individually 
        This.equals(a,b) to the corresponding element in 'that'.
        This can be different from '==' or 'readEquality': they just use system equality.
        If the elements have a 'readEquality' method, that is used
        On default This.equals(a,b) will use an available equality predicate visible on the element; 
        prioritizing in the following order:
        'allEq', 'readEquality' and '=='.
        If none is present, 'System.immEquality' is used instead.
        }read method Bool allEq(read This that)=(..)
      clone()                            read method capsule This clone()=(..)
      contains(that)                     @{
        Predicate
        True if the element is contained in the List.
        }read method Bool contains(read This1 that)=(..)
      indexOf(left)                      @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the leftmost occurrence
        of 'left' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 left)=(..)
      indexOf(right)                     @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the rightmost occurrence
        of 'right' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 right)=(..)
      isEmpty()                          read method Bool isEmpty()native{..}=(..)
      isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
      left()                             read method This1 left()=(..)
      readEquality(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }read method Bool readEquality(read This that)=(..)
      readLeft()                         read method read This1 readLeft()=(..)
      readRight()                        read method read This1 readRight()=(..)
      readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
      right()                            read method This1 right()=(..)
      size()                             read method I size()native{..}=(..)
      toS()                              read method S toS()=(..)
      val(that)                          read method This1 val(I that)native{..}=(..)
      vals()                             read method read This vals()=(..)
      vals(that)                         read method read Iterator vals(I that)=(..)
      vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
      vals(to)                           read method read Iterator vals(I to)=(..)
      //mut methods:
      #add(left)                         mut method Void #add(mut This1 left)=(..)
      #add(right)                        mut method Void #add(mut This1 right)=(..)
      #add(that)                         mut method Void #add(mut This1 that)=(..)
      #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
      #apply(that)                       mut method mut This #apply(Void that)=(..)
      #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
      #left()                            mut method mut This1 #left()=(..)
      #left(that)                        mut method Void #left(mut This1 that)=(..)
      #right()                           mut method mut This1 #right()=(..)
      #right(that)                       mut method Void #right(mut This1 that)=(..)
      #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
      #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
      #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
      #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
      #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
      #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
      #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
      #vals()                            mut method mut This #vals()=(..)
      #vals(that)                        mut method mut Iterator #vals(I that)=(..)
      #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
      #vals(to)                          mut method mut Iterator #vals(I to)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      add(left)                          mut method Void add(This1 left)=(..)
      add(right)                         mut method Void add(This1 right)=(..)
      add(that)                          mut method Void add(This1 that)=(..)
      add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
      clear()                            mut method Void clear()=(..)
      left(that)                         mut method Void left(This1 that)=(..)
      remove(left)                       @{
        Mutator 
        Removes from the list the leftmost element equal to 'left'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
        }mut method Void remove(read This1 left)=(..)
      remove(right)                      @{
        Mutator 
        Removes from the list the rightmost element equal to 'right'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
        }mut method Void remove(read This1 right)=(..)
      remove(that)                       mut method Void remove(I that)native{..}=(..)
      removeAll(val)                     @{
        Mutator 
        Removes from the list all the elements equal to 'val'.
        It relies on 'This.equals(a,b)'  
        }mut method Void removeAll(read This1 val)=(..)
      removeLeft()                       mut method Void removeLeft()=(..)
      removeRight()                      mut method Void removeRight()=(..)
      right(that)                        mut method Void right(This1 that)=(..)
      set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
      Iterator={
        //class methods:
        #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
        //read methods:
        #elem#default(that)                read method This2 #elem#default(I that)=(..)
        #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
        #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
        #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
        #iterator()                        read method read This #iterator()=(..)
        #startIndex()                      read method I #startIndex()=(..)
        end()                              read method I end()=(..)
        list()                             read method read This1 list()=(..)
        start()                            read method I start()=(..)
        //mut methods:
        #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
        #list()                            mut method mut This1 #list()=(..)
        #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
        #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
        #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
        #varIterator()                     mut method mut This #varIterator()=(..)
        }
      }
    @Public Opt={
      [HasToS]
      //class methods:
      #apply()                           class method mut This #apply()=(..)
      #apply(that)                       class method mut This #apply(fwd mut This1 that)native{..}=(..)
      equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
      //imm methods:
      #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
      //read methods:
      #bang0()                           read method Bool #bang0()=(..)
      #if()                              read method Bool #if()native{..}=(..)
      #in1(that)                         read method Bool #in1(read This1 that)=(..)
      allEq(that)                        read method Bool allEq(read This that)=(..)
      contains(that)                     read method Bool contains(read This1 that)=(..)
      isPresent()                        read method Bool isPresent()=(..)
      readEquality(that)                 read method Bool readEquality(read This that)=(..)
      toS()                              read method S toS()=(..)
      val()                              read method read This1 val()native{..}=(..)
      val(orElse)                        read method read This1 val(read This1 orElse)=(..)
      //mut methods:
      #val()                             mut method mut This1 #val()native{..}=(..)
      #val(orElse)                       mut method mut This1 #val(mut This1 orElse)=(..)
      }
    }
  @Public List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @Public Method={
    [HasToS]
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    doc()                              @Public method Doc doc()=(..)
    exceptions()                       @Public method Type.List exceptions()=(..)
    info()                             @Public method This1 info()=(..)
    isAbstract()                       @Public method Bool isAbstract()=(..)
    isRefined()                        @Public method Bool isRefined()=(..)
    nameFromRoot()                     @Public method Name nameFromRoot()=(..)
    parameters()                       @Public method Type.List parameters()=(..)
    position()                         @Public method S position()=(..)
    returnType()                       @Public method Type returnType()=(..)
    selector()                         @Public method S selector()=(..)
    //read methods:
    toS()                              read method S toS()=(..)
    @Public List={
      [HasToS]
      //class methods:
      #apply()                           class method mut This #apply()=(..)
      #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
      #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
      #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
      #squareBuilder()                   class method mut This #squareBuilder()=(..)
      equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
      //imm methods:
      #bangequal0(that)                  @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #equalequal0(This that)=(..)
      #minus0(right)                     @{
        Wither
        Returns the receiver but without all the elements equal to 'right'
        }method This #minus0(This1 right)=(..)
      #minusminus0(right)                @{
        Wither
        Returns the receiver but without all the elements contained in the list 'right'
        }method This #minusminus0(This right)=(..)
      #plus0(right)                      method This #plus0(This1 right)=(..)
      #plus1(left)                       method This #plus1(This1 left)=(..)
      #plusplus0(right)                  method This #plusplus0(This right)=(..)
      immNorm()                          method This immNorm()=(..)
      with(left)                         method This with(This1 left)=(..)
      with(right)                        method This with(This1 right)=(..)
      with(that, val)                    method This with(I that, This1 val)=(..)
      withAlso(left)                     method This withAlso(This1 left)=(..)
      withAlso(right)                    method This withAlso(This1 right)=(..)
      withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
      without(left)                      @{
        Wither
        Returns the receiver but without the leftmost element equal to 'val'
        }method This without(read This1 left)=(..)
      without(right)                     @{
        Wither
        Returns the receiver but without the rightmost element equal to 'val'
        }method This without(read This1 right)=(..)
      without(that)                      method This without(I that)=(..)
      withoutAll(val)                    @{
        Wither
        Returns the receiver but without all the elements equal to 'val'
        }method This withoutAll(read This1 val)=(..)
      withoutLeft()                      method This withoutLeft()=(..)
      withoutRight()                     method This withoutRight()=(..)
      //read methods:
      #elem#default(that)                read method This1 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #in1(that)                         @{
        Predicate
        True if the element is contained in the List.
        }read method Bool #in1(read This1 that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      allEq(that)                        @{
        Predicate
        returns true if all the elements in 'this' are individually 
        This.equals(a,b) to the corresponding element in 'that'.
        This can be different from '==' or 'readEquality': they just use system equality.
        If the elements have a 'readEquality' method, that is used
        On default This.equals(a,b) will use an available equality predicate visible on the element; 
        prioritizing in the following order:
        'allEq', 'readEquality' and '=='.
        If none is present, 'System.immEquality' is used instead.
        }read method Bool allEq(read This that)=(..)
      clone()                            read method capsule This clone()=(..)
      contains(that)                     @{
        Predicate
        True if the element is contained in the List.
        }read method Bool contains(read This1 that)=(..)
      indexOf(left)                      @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the leftmost occurrence
        of 'left' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 left)=(..)
      indexOf(right)                     @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the rightmost occurrence
        of 'right' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 right)=(..)
      isEmpty()                          read method Bool isEmpty()native{..}=(..)
      isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
      left()                             read method This1 left()=(..)
      readEquality(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }read method Bool readEquality(read This that)=(..)
      readLeft()                         read method read This1 readLeft()=(..)
      readRight()                        read method read This1 readRight()=(..)
      readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
      right()                            read method This1 right()=(..)
      size()                             read method I size()native{..}=(..)
      toS()                              read method S toS()=(..)
      val(that)                          read method This1 val(I that)native{..}=(..)
      vals()                             read method read This vals()=(..)
      vals(that)                         read method read Iterator vals(I that)=(..)
      vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
      vals(to)                           read method read Iterator vals(I to)=(..)
      //mut methods:
      #add(left)                         mut method Void #add(mut This1 left)=(..)
      #add(right)                        mut method Void #add(mut This1 right)=(..)
      #add(that)                         mut method Void #add(mut This1 that)=(..)
      #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
      #apply(that)                       mut method mut This #apply(Void that)=(..)
      #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
      #left()                            mut method mut This1 #left()=(..)
      #left(that)                        mut method Void #left(mut This1 that)=(..)
      #right()                           mut method mut This1 #right()=(..)
      #right(that)                       mut method Void #right(mut This1 that)=(..)
      #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
      #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
      #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
      #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
      #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
      #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
      #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
      #vals()                            mut method mut This #vals()=(..)
      #vals(that)                        mut method mut Iterator #vals(I that)=(..)
      #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
      #vals(to)                          mut method mut Iterator #vals(I to)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      add(left)                          mut method Void add(This1 left)=(..)
      add(right)                         mut method Void add(This1 right)=(..)
      add(that)                          mut method Void add(This1 that)=(..)
      add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
      clear()                            mut method Void clear()=(..)
      left(that)                         mut method Void left(This1 that)=(..)
      remove(left)                       @{
        Mutator 
        Removes from the list the leftmost element equal to 'left'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
        }mut method Void remove(read This1 left)=(..)
      remove(right)                      @{
        Mutator 
        Removes from the list the rightmost element equal to 'right'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
        }mut method Void remove(read This1 right)=(..)
      remove(that)                       mut method Void remove(I that)native{..}=(..)
      removeAll(val)                     @{
        Mutator 
        Removes from the list all the elements equal to 'val'.
        It relies on 'This.equals(a,b)'  
        }mut method Void removeAll(read This1 val)=(..)
      removeLeft()                       mut method Void removeLeft()=(..)
      removeRight()                      mut method Void removeRight()=(..)
      right(that)                        mut method Void right(This1 that)=(..)
      set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
      Iterator={
        //class methods:
        #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
        //read methods:
        #elem#default(that)                read method This2 #elem#default(I that)=(..)
        #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
        #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
        #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
        #iterator()                        read method read This #iterator()=(..)
        #startIndex()                      read method I #startIndex()=(..)
        end()                              read method I end()=(..)
        list()                             read method read This1 list()=(..)
        start()                            read method I start()=(..)
        //mut methods:
        #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
        #list()                            mut method mut This1 #list()=(..)
        #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
        #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
        #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
        #varIterator()                     mut method mut This #varIterator()=(..)
        }
      }
    }
  @Public Type={
    [HasToS]
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    doc()                              @Public method Doc doc()=(..)
    info()                             @Public method This1 info()=(..)
    mdf()                              @{
      return a string in the set "read","imm","fwd imm","mut","fwd mut","lent","capsule","class"
      }@Public method S mdf()=(..)
    //read methods:
    toS()                              read method S toS()=(..)
    @Public List={
      [HasToS]
      //class methods:
      #apply()                           class method mut This #apply()=(..)
      #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
      #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
      #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
      #squareBuilder()                   class method mut This #squareBuilder()=(..)
      equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
      //imm methods:
      #bangequal0(that)                  @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }method Bool #equalequal0(This that)=(..)
      #minus0(right)                     @{
        Wither
        Returns the receiver but without all the elements equal to 'right'
        }method This #minus0(This1 right)=(..)
      #minusminus0(right)                @{
        Wither
        Returns the receiver but without all the elements contained in the list 'right'
        }method This #minusminus0(This right)=(..)
      #plus0(right)                      method This #plus0(This1 right)=(..)
      #plus1(left)                       method This #plus1(This1 left)=(..)
      #plusplus0(right)                  method This #plusplus0(This right)=(..)
      immNorm()                          method This immNorm()=(..)
      with(left)                         method This with(This1 left)=(..)
      with(right)                        method This with(This1 right)=(..)
      with(that, val)                    method This with(I that, This1 val)=(..)
      withAlso(left)                     method This withAlso(This1 left)=(..)
      withAlso(right)                    method This withAlso(This1 right)=(..)
      withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
      without(left)                      @{
        Wither
        Returns the receiver but without the leftmost element equal to 'val'
        }method This without(read This1 left)=(..)
      without(right)                     @{
        Wither
        Returns the receiver but without the rightmost element equal to 'val'
        }method This without(read This1 right)=(..)
      without(that)                      method This without(I that)=(..)
      withoutAll(val)                    @{
        Wither
        Returns the receiver but without all the elements equal to 'val'
        }method This withoutAll(read This1 val)=(..)
      withoutLeft()                      method This withoutLeft()=(..)
      withoutRight()                     method This withoutRight()=(..)
      //read methods:
      #elem#default(that)                read method This1 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #in1(that)                         @{
        Predicate
        True if the element is contained in the List.
        }read method Bool #in1(read This1 that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      allEq(that)                        @{
        Predicate
        returns true if all the elements in 'this' are individually 
        This.equals(a,b) to the corresponding element in 'that'.
        This can be different from '==' or 'readEquality': they just use system equality.
        If the elements have a 'readEquality' method, that is used
        On default This.equals(a,b) will use an available equality predicate visible on the element; 
        prioritizing in the following order:
        'allEq', 'readEquality' and '=='.
        If none is present, 'System.immEquality' is used instead.
        }read method Bool allEq(read This that)=(..)
      clone()                            read method capsule This clone()=(..)
      contains(that)                     @{
        Predicate
        True if the element is contained in the List.
        }read method Bool contains(read This1 that)=(..)
      indexOf(left)                      @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the leftmost occurrence
        of 'left' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 left)=(..)
      indexOf(right)                     @{
        Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
        The result is the index of the rightmost occurrence
        of 'right' in the list according to 'This.equals(a,b)'
        }read method I indexOf(read This1 right)=(..)
      isEmpty()                          read method Bool isEmpty()native{..}=(..)
      isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
      left()                             read method This1 left()=(..)
      readEquality(that)                 @{
        Predicate
        Delegates to 'System.immEquality'.
        Look at 'allEq' for more flexible equivalence checks.
        }read method Bool readEquality(read This that)=(..)
      readLeft()                         read method read This1 readLeft()=(..)
      readRight()                        read method read This1 readRight()=(..)
      readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
      right()                            read method This1 right()=(..)
      size()                             read method I size()native{..}=(..)
      toS()                              read method S toS()=(..)
      val(that)                          read method This1 val(I that)native{..}=(..)
      vals()                             read method read This vals()=(..)
      vals(that)                         read method read Iterator vals(I that)=(..)
      vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
      vals(to)                           read method read Iterator vals(I to)=(..)
      //mut methods:
      #add(left)                         mut method Void #add(mut This1 left)=(..)
      #add(right)                        mut method Void #add(mut This1 right)=(..)
      #add(that)                         mut method Void #add(mut This1 that)=(..)
      #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
      #apply(that)                       mut method mut This #apply(Void that)=(..)
      #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
      #left()                            mut method mut This1 #left()=(..)
      #left(that)                        mut method Void #left(mut This1 that)=(..)
      #right()                           mut method mut This1 #right()=(..)
      #right(that)                       mut method Void #right(mut This1 that)=(..)
      #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
      #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
      #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
      #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
      #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
      #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
      #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
      #vals()                            mut method mut This #vals()=(..)
      #vals(that)                        mut method mut Iterator #vals(I that)=(..)
      #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
      #vals(to)                          mut method mut Iterator #vals(I to)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      add(left)                          mut method Void add(This1 left)=(..)
      add(right)                         mut method Void add(This1 right)=(..)
      add(that)                          mut method Void add(This1 that)=(..)
      add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
      clear()                            mut method Void clear()=(..)
      left(that)                         mut method Void left(This1 that)=(..)
      remove(left)                       @{
        Mutator 
        Removes from the list the leftmost element equal to 'left'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
        }mut method Void remove(read This1 left)=(..)
      remove(right)                      @{
        Mutator 
        Removes from the list the rightmost element equal to 'right'.
        It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
        }mut method Void remove(read This1 right)=(..)
      remove(that)                       mut method Void remove(I that)native{..}=(..)
      removeAll(val)                     @{
        Mutator 
        Removes from the list all the elements equal to 'val'.
        It relies on 'This.equals(a,b)'  
        }mut method Void removeAll(read This1 val)=(..)
      removeLeft()                       mut method Void removeLeft()=(..)
      removeRight()                      mut method Void removeRight()=(..)
      right(that)                        mut method Void right(This1 that)=(..)
      set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
      Iterator={
        //class methods:
        #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
        //read methods:
        #elem#default(that)                read method This2 #elem#default(I that)=(..)
        #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
        #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
        #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
        #iterator()                        read method read This #iterator()=(..)
        #startIndex()                      read method I #startIndex()=(..)
        end()                              read method I end()=(..)
        list()                             read method read This1 list()=(..)
        start()                            read method I start()=(..)
        //mut methods:
        #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
        #list()                            mut method mut This1 #list()=(..)
        #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
        #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
        #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
        #varIterator()                     mut method mut This #varIterator()=(..)
        }
      }
    }
  @AbstractTowel{
    introspection
    }
  }
@Public Load={
  //class methods:
  #apply()                           class method This #apply()=(..)
  #apply(deps)                       class method This #apply(Info.List deps)=(..)
  baseDeps()                         class method mut Info.List baseDeps()=(..)
  //imm methods:
  #colon0(that)                      method Library #colon0(Library that)[Trait.InvalidName, Trait.InvalidMap, Trait.MethodClash, Trait.ClassClash]=(..)
  #colon0(trait)                     method Trait #colon0(Trait trait)[Trait.InvalidName, Trait.InvalidMap, Trait.MethodClash, Trait.ClassClash]=(..)
  collect(that)                      method Trait.Acc collect(Library that)=(..)
  match(src, dest)                   method Bool match(S src, S dest)=(..)
  //read methods:
  deps()                             read method Info.List deps()=(..)
  ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  N={
    #colon0(a)                         class method Info #colon0(class Any a)=(..)
    ClassOperators={
      #apply()                           class method class This1 #apply()=(..)
      }
    }
  @AbstractTowel{
    load
    }
  }
@Public Log={
  //class methods:
  #apply(that)                       class method This #apply(S that)=(..)
  #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
  //read methods:
  #$reader()                         read method mut This #$reader()=(..)
  clear()                            read method Void clear()=(..)
  write(that)                        read method Void write(S that)=(..)
  //mut methods:
  read()                             mut method S read()=(..)
  @AbstractTowel{
    log
    }
  }
@Public Match={
  @Public All={
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    //mut methods:
    #apply(that)                       @Public mut method Bool #apply(Void that)=(..)
    add(that)                          @Public mut method Void add(Bool that)[Void]=(..)
    }
  @Public None={
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    //mut methods:
    #apply(that)                       @Public mut method Bool #apply(Void that)=(..)
    add(that)                          @Public mut method Void add(Bool that)[Void]=(..)
    }
  @Public Some={
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    //mut methods:
    #apply(that)                       @Public mut method Bool #apply(Void that)=(..)
    add(that)                          @Public mut method Void add(Bool that)[Void]=(..)
    }
  @AbstractTowel{
    match
    }
  }
@Public Math={
  maxI()                             class method I maxI()=(..)
  maxLong()                          class method Long maxLong()=(..)
  minI()                             class method I minI()=(..)
  minLong()                          class method Long minLong()=(..)
  minusInfinty()                     class method Double minusInfinty()=(..)
  minusZero()                        class method Double minusZero()=(..)
  nan()                              class method Double nan()=(..)
  pi()                               class method Double pi()=(..)
  plusInfinty()                      class method Double plusInfinty()=(..)
  randomList(that)                   class method Library randomList(class Any that)[Class.IncoherentClass, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  tau()                              class method Double tau()=(..)
  ArithmeticError={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  Long={
    [HasToS, Numeric]
    //class methods:
    #apply(num)                        class method This #apply(Num num)native{..}=(..)
    #apply(string)                     class method This #apply(S string)=(..)
    #apply(that)                       class method This #apply(Numeric that)=(..)
    #from(stringLiteral)               @Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
    zero()                             class method This zero()=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #divide0(that)                     method This #divide0(This that)native{..}=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    #gt0(that)                         method Bool #gt0(This that)=(..)
    #gtequal0(that)                    method Bool #gtequal0(This that)=(..)
    #lt0(that)                         method Bool #lt0(This that)native{..}=(..)
    #ltequal0(that)                    method Bool #ltequal0(This that)native{..}=(..)
    #minus0(that)                      method This #minus0(This that)native{..}=(..)
    #plus0(that)                       method This #plus0(This that)native{..}=(..)
    #times0(that)                      method This #times0(This that)native{..}=(..)
    acc()                              method mut Acc acc()=(..)
    ceil()                             method I ceil()native{..}=(..)
    clamp(that, max)                   method This clamp(This that, This max)=(..)
    clamp(that, to)                    method This clamp(This that, This to)=(..)
    floor()                            method I floor()native{..}=(..)
    isInRange(that, to)                method Bool isInRange(This that, This to)=(..)
    max(that)                          method This max(This that)=(..)
    min(that)                          method This min(This that)=(..)
    mod(that)                          method This mod(This that)native{..}=(..)
    pred()                             method This pred()native{..}=(..)
    round()                            method I round()native{..}=(..)
    signum()                           method I signum()native{..}=(..)
    succ()                             method This succ()native{..}=(..)
    toDouble()                         method Double toDouble()native{..}=(..)
    toI()                              method I toI()native{..}=(..)
    toLong()                           method This toLong()=(..)
    toNum()                            method Num toNum()=(..)
    toNum(denominator)                 method Num toNum(This denominator)=(..)
    //read methods:
    readEquality(that)                 read method Bool readEquality(read This that)native{..}=(..)
    toS()                              read method S toS()native{..}=(..)
    Acc={
      //class methods:
      #apply(val)                        class method mut This #apply(This1 val)=(..)
      //read methods:
      val()                              read method This1 val()=(..)
      //mut methods:
      #apply(that)                       mut method This1 #apply(Void that)=(..)
      add(that)                          mut method Void add(This1 that)=(..)
      addIf(that)                        mut method Void addIf(Bool that)=(..)
      addOne()                           mut method Void addOne()=(..)
      divide(that)                       mut method Void divide(This1 that)=(..)
      times(that)                        mut method Void times(This1 that)=(..)
      val(that)                          mut method Void val(This1 that)=(..)
      }
    @AbstractTowel{
      long
      }
    }
  Numeric={
    interface
    //class methods:
    #apply(that)                       @{
      This method creates an instance of the current type from another @This.
      Any class implementing @This should refine the return type to its own This type.
      }class method This #apply(This that)
    //imm methods:
    toDouble()                         method Double toDouble()
    toI()                              method I toI()
    toLong()                           method Long toLong()
    toNum()                            method Num toNum()
    }
  Random={
    //class methods:
    #$random()                         class method mut This #$random()=(..)
    #apply(seed)                       class method mut This #apply(Long seed)=(..)
    //mut methods:
    nextDouble()                       mut method Double nextDouble()=(..)
    nextInRange(that, to)              mut method I nextInRange(I that, I to)=(..)
    nextLong()                         mut method Long nextLong()=(..)
    radiant()                          mut method Double radiant()=(..)
    }
  RandomListTrait={
    [Trait.Lifted]
    #apply()                           class method Trait #apply()=(..)
    #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
    #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    code()                             class method Library code()=(..)
    info()                             class method Info info()=(..)
    resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
    ClassOperators={
      #apply()                           class method Trait #apply()=(..)
      }
    }
  Support={
    [Trait.Lifted]
    #apply()                           class method Trait #apply()=(..)
    #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
    #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    code()                             class method Library code()=(..)
    info()                             class method Info info()=(..)
    resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
    ClassOperators={
      #apply()                           class method Trait #apply()=(..)
      }
    }
  @AbstractTowel{
    math
    }
  }
@Public Message={
  interface[HasToS]
  //class methods:
  #apply(that)                       @Public class method mut This #apply(S that)
  #from(stringLiteral)               @Public class method This #from(S.StringBuilder stringLiteral)
  //imm methods:
  #whoopsed(atPos)                   @Public method This #whoopsed(Library atPos)
  //read methods:
  text()                             @Public read method S text()
  toS()                              read method S toS()
  //mut methods:
  text(that)                         @Public mut method Void text(S that)
  @Public Assert={
    interface[This1, HasToS]
    //class methods:
    #apply(that)                       class method mut This1 #apply(S that)
    #from(stringLiteral)               class method This1 #from(S.StringBuilder stringLiteral)
    //imm methods:
    #whoopsed(atPos)                   method This1 #whoopsed(Library atPos)
    //read methods:
    text()                             read method S text()
    toS()                              read method S toS()
    //mut methods:
    text(that)                         mut method Void text(S that)
    }
  @Public ClassOperators={
    #apply()                           class method class This #apply()=(..)
    #colon0(that)                      class method Library #colon0(Library that)[Trait.ClassClash, Trait.MethodClash]=(..)
    #colon0(trait)                     class method Trait #colon0(Trait trait)[Trait.ClassClash, Trait.MethodClash]=(..)
    }
  @Public Guard={
    interface[This1, HasToS]
    //class methods:
    #apply(that)                       class method mut This1 #apply(S that)
    #from(stringLiteral)               class method This1 #from(S.StringBuilder stringLiteral)
    //imm methods:
    #whoopsed(atPos)                   method This1 #whoopsed(Library atPos)
    //read methods:
    text()                             read method S text()
    toS()                              read method S toS()
    //mut methods:
    text(that)                         mut method Void text(S that)
    }
  @Public Native={
    #apply()                           class method Trait #apply()=(..)
    ClassOperators={
      #apply()                           class method Trait #apply()=(..)
      }
    }
  @Public OptMessage={
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(that)                       class method mut This #apply(fwd mut This1 that)native{..}=(..)
    //read methods:
    #if()                              read method Bool #if()native{..}=(..)
    val()                              read method read This1 val()native{..}=(..)
    //mut methods:
    #val()                             mut method mut This1 #val()native{..}=(..)
    }
  @AbstractTowel{
    message
    }
  }
@Public Name={
  [HasToS]
  //class methods:
  #apply(string)                     @Public class method This #apply(S string)=(..)
  #from(stringLiteral)               @Public@Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
  validX(that)                       @Public class method Bool validX(S that)=(..)
  //imm methods:
  #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
  #equalgt0(nested)                  @Public method Mapping #equalgt0(Info nested)=(..)
  #equalgt0(other)                   @Public method Mapping #equalgt0(This other)=(..)
  #equalgt0(target)                  @Public method Mapping #equalgt0(class Any target)=(..)
  #minusgt0(other)                   @Public method Mapping #minusgt0(This other)=(..)
  #plusplus1(prefix)                 @Public method This #plusplus1(S prefix)=(..)
  #times1(n)                         @Public method Info #times1(Info n)=(..)
  #times1(that)                      @Public method class Any #times1(class Any that)=(..)
  path()                             @Public method S path()=(..)
  selector()                         @Public method S selector()=(..)
  with(path)                         @Public method This with(S path)=(..)
  with(selector)                     @Public method This with(S selector)=(..)
  with(x)                            @Public method This with(S x)=(..)
  with(xs)                           @Public method This with(S.List xs)=(..)
  x()                                @Public method S x()=(..)
  xs()                               @Public method S.List xs()=(..)
  //read methods:
  readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
  toS()                              read method S toS()=(..)
  @Public List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @Public Mapping={
    #apply()                           @Public class method This #apply()=(..)
    #from(stringLiteral)               @Public@Cache.Call class method This1 #from(S.StringBuilder stringLiteral)=(..)
    }
  @AbstractTowel{
    name
    }
  }
@Public Num={
  [HasToS, Math.Numeric]
  //class methods:
  #apply(string)                     class method This #apply(S string)=(..)
  #apply(that)                       class method This #apply(Math.Numeric that)=(..)
  #from(stringLiteral)               @Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
  zero()                             class method This zero()=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #divide0(that)                     method This #divide0(This that)native{..}=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  #gt0(that)                         method Bool #gt0(This that)=(..)
  #gtequal0(that)                    method Bool #gtequal0(This that)=(..)
  #lt0(that)                         method Bool #lt0(This that)native{..}=(..)
  #ltequal0(that)                    method Bool #ltequal0(This that)native{..}=(..)
  #minus0(that)                      method This #minus0(This that)native{..}=(..)
  #plus0(that)                       method This #plus0(This that)native{..}=(..)
  #times0(that)                      method This #times0(This that)native{..}=(..)
  acc()                              method mut Acc acc()=(..)
  ceil()                             method I ceil()=(..)
  clamp(that, max)                   method This clamp(This that, This max)=(..)
  floor()                            method I floor()=(..)
  isInRange(that, to)                method Bool isInRange(This that, This to)=(..)
  max(that)                          method This max(This that)=(..)
  min(that)                          method This min(This that)=(..)
  pred()                             @{
    Meta-programming friendly method.
    The predecessor operation. Simply subtracts 1
    }method This pred()native{..}=(..)
  round()                            method I round()=(..)
  succ()                             @{
    Meta-programming friendly method.
    The successor operation. Simply adds 1
    }method This succ()native{..}=(..)
  toDouble()                         method Double toDouble()=(..)
  toI()                              method I toI()=(..)
  toLong()                           method Math.Long toLong()=(..)
  toNum()                            method This toNum()=(..)
  //read methods:
  readEquality(that)                 read method Bool readEquality(read This that)native{..}=(..)
  toS()                              read method S toS()native{..}=(..)
  Acc={
    //class methods:
    #apply(val)                        class method mut This #apply(This1 val)=(..)
    //read methods:
    val()                              read method This1 val()=(..)
    //mut methods:
    #apply(that)                       mut method This1 #apply(Void that)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    addIf(that)                        mut method Void addIf(Bool that)=(..)
    addOne()                           mut method Void addOne()=(..)
    divide(that)                       mut method Void divide(This1 that)=(..)
    times(that)                        mut method Void times(This1 that)=(..)
    val(that)                          mut method Void val(This1 that)=(..)
    }
  List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @AbstractTowel{
    num
    }
  }
@Public Organize={
  //class methods:
  #apply()                           @Public class method This #apply()=(..)
  //imm methods:
  #colon0(lifted)                    @Public method Trait #colon0(class Trait.Lifted lifted)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  #colon0(that)                      @Public method Library #colon0(Library that)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  #colon0(trait)                     @Public method Trait #colon0(Trait trait)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  @Public ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  @AbstractTowel{
    organize
    }
  }
@Public Public={
  //class methods:
  #apply()                           @This class method This #apply()=(..)
  #apply(private)                    @This class method This #apply(Info private)=(..)
  #apply(public)                     @This class method This #apply(Info public)=(..)
  #apply(public, private)            @This class method This #apply(Info public, Info private)=(..)
  //imm methods:
  #colon0(lib)                       @This method Library #colon0(Library lib)[Data.Close.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  #colon0(that)                      @This method Trait #colon0(Trait that)[Data.Close.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  @This ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  @AbstractTowel{
    public
    }
  }
@Public Range={
  [Indexes]
  //class methods:
  #apply(that)                       @{
    Factory method
    A range from zero (included) up to 'that' (excluded).
    }@Public class method This #apply(I that)=(..)
  #apply(that, to)                   @{
    Factory method
    A range from 'that' (included) up to 'to' (excluded).
    }@Public class method This #apply(I that, I to)=(..)
  unbounded()                        @{
    Factory method
    behaves like 'unbounded(0I)'
    }@Public class method Unbounded unbounded()=(..)
  unbounded(that)                    @{
    Factory method
    Creates an endless range starting from 'that'
    Since it is iterating on indexes, it is eventually going to overflow
    and keep going over negative indexes.
    If iterated together with other collections, it will behave like a
    'cut-view' thus allowing for an early termination   
    }@Public class method Unbounded unbounded(I that)=(..)
  //imm methods:
  #elem#default(that)                @Public method I #elem#default(I that)=(..)
  #endIndex()                        @Public method I #endIndex()=(..)
  #hasElem(that)                     @Public method Collection.IteratorCompose #hasElem(I that)=(..)
  #iterator()                        @Public method This #iterator()=(..)
  #startIndex()                      @Public method I #startIndex()=(..)
  andThen(that)                      @Public method Indexes andThen(Indexes that)=(..)
  reverse()                          @{
    Factory method
    Creates a reverse range; a range exploring the sequence in the reverse order.
    }@Public method Reverse reverse()=(..)
  steps()                            @Public method I steps()=(..)
  @Public AndThen={
    [Indexes]
    #elem#default(that)                @Public method I #elem#default(I that)=(..)
    #endIndex()                        @Public method I #endIndex()=(..)
    #hasElem(that)                     @Public method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        @Public method This #iterator()=(..)
    #startIndex()                      @Public method I #startIndex()=(..)
    andThen(that)                      @Public method Indexes andThen(Indexes that)=(..)
    }
  @Public Indexes={
    interface
    #elem#default(that)                method I #elem#default(I that)
    #endIndex()                        method I #endIndex()
    #hasElem(that)                     method Collection.IteratorCompose #hasElem(I that)
    #iterator()                        method This #iterator()
    #startIndex()                      method I #startIndex()
    andThen(that)                      method This andThen(This that)
    }
  @Public Reverse={
    [Indexes]
    #elem#default(that)                @Public method I #elem#default(I that)=(..)
    #endIndex()                        @Public method I #endIndex()=(..)
    #hasElem(that)                     @Public method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        @Public method This #iterator()=(..)
    #startIndex()                      @Public method I #startIndex()=(..)
    andThen(that)                      @Public method Indexes andThen(Indexes that)=(..)
    }
  @Public Unbounded={
    [Indexes]
    #elem#default(that)                @Public method I #elem#default(I that)=(..)
    #endIndex()                        @Public method I #endIndex()=(..)
    #hasElem(that)                     @Public method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        @Public method This #iterator()=(..)
    #startIndex()                      @Public method I #startIndex()=(..)
    andThen(that)                      @Public method Indexes andThen(Indexes that)=(..)
    }
  @AbstractTowel{
    range
    }
  }
@Public S={
  [HasToS, HasToS.Raw]
  //class methods:
  #apply(string)                     @{
    Meta-programming friendly method.
    For this class it just returns the argument.
    }@Public class method This #apply(This string)=(..)
  #from(stringLiteral)               @Public@Cache.Call class method This #from(StringBuilder stringLiteral)=(..)
  allUpLow()                         @Public@Cache.Lazy class method List allUpLow()native{..}=(..)
  dq()                               @{
    Returns a string composed only of the double quote character (").
    }@Public class method This dq()=(..)
  lowToUp()                          @Public@Cache.Lazy class method Map lowToUp()native{..}=(..)
  nl()                               @{
    Returns a string composed only of the new line character.
    }@Public class method This nl()=(..)
  percent()                          @{
    Returns a string composed only of the percent character (%).
    }@Public class method This percent()=(..)
  tab()                              @{
    Returns a string composed only of the tab character.
    }@Public class method This tab()=(..)
  upToLow()                          @Public@Cache.Lazy class method Map upToLow()native{..}=(..)
  //imm methods:
  #bangequal0(that)                  @{
    Structural inequality on strings.
    }@Public method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @{
    Structural equality on strings.
    }@Public method Bool #equalequal0(This that)=(..)
  #plusplus0(that)                   @{
    String concatenation.
    }@Public method This #plusplus0(This that)native{..}=(..)
  builder()                          @{
    Returns a mutable string builder object starting with the receiver string.
    This allows for efficient concatenation of many strings.
    Below we show that using the #apply method of the builder,
    this can be used as a convenient syntax to accumulate many strings in a loop.
    
    S res = S"foo".builder()(for x in xs \add(x.bar())
    }@Public method mut StringBuilder builder()=(..)
  contains(that)                     @{
    Strings containment.
    Returns true iff the receiver contains the argument string.
    }@Public method Bool contains(This that)native{..}=(..)
  decodeBase64()                     @{
    Base64 support
    Strings in AdamsTowel only contain a limited set of safe chars.
    To represent 'stringy' data with other chars/unicode-chars/binary data
    you can use the base64 encoding.
    This method decodes the current base64 encoded string into a human readable string.
    Any (encoded) chars that are not representable
    by AdamsTowel strings are pruned away from the result.
    }@Public method This decodeBase64()native{..}=(..)
  encodeBase64()                     @{
    Base64 support
    Strings in AdamsTowel only contain a limited set of safe chars.
    To represent 'stringy' data with other chars/unicode-chars/binary data
    you can use the base64 encoding.
    This method encodes the current string in its Base64 form.
    }@Public method This encodeBase64()native{..}=(..)
  endsWith(that)                     @{
    Tests if this string ends with the specified suffix.
    }@Public method Bool endsWith(This that)native{..}=(..)
  endsWith(that, rightOffSet)        @{
    Tests if the substring ending at the specified index ends with the specified prefix.
    }@Public method Bool endsWith(This that, I rightOffSet)native{..}=(..)
  indexOf(that)                      @{
    Indexing inside a string:
    Behaves like @This.indexOf(that,from)
    with from = 0.
    }@Public method I indexOf(This that)=(..)
  indexOf(that, from)                @{
    Indexing inside a string:
    Returns the index within this string of the leftmost 
    occurrence of the specified substring, starting from the provided index.
    If no such occurrence exists, -1 is returned.
    }@Public method I indexOf(This that, I from)native{..}=(..)
  lastIndexOf(that)                  @{
    Indexing inside a string:
    Behaves like @This.lastIndexOf(that,from)
    with from = 0.
    }@Public method I lastIndexOf(This that)=(..)
  lastIndexOf(that, from)            @{
    Indexing inside a string:
    Returns the index within this string of the rightmost 
    occurrence of the specified substring,
    searching backwards starting from the provided index.
    If no such occurrence exists, -1 is returned.
    }@Public method I lastIndexOf(This that, I from)native{..}=(..)
  replace(that, with)                @{
    String replacement.
    Replaces each substring of the receiver that matches the first argument 
    with the second argument.
    The replacement proceeds from left to right,
    for example, replacing "aa" with "b" in the string "aaa" will result in "ba" rather than "ab".
    }@Public method This replace(This that, This with)native{..}=(..)
  split()                            @Public method mut Chariterator split()=(..)
  split(that)                        @{
    Splits on the separator 'that'.
    Corner cases are handled by the following rules, that applies in order:
      - if the string is empty this is the empty iterator.
      - if the separator is empty, this iterator contains the whole string as a single element
      - if the separator is not contained in the string, this iterator contains the whole string as a single element
      - if the string ends and/or starts by the separator, it is splitted exactly as a string with those
        starting/ending separators removed.
      - if the string contains multiple occourrences of the separator without 
        any other character in the middle, the iterator will step on an empty string while crossing them.
    }@Public method mut Spliterator split(This that)=(..)
  split(that, to)                    @Public method mut Chariterator split(I that, I to)=(..)
  startsWith(that)                   @{
    Tests if this string starts with the specified prefix.
    }@Public method Bool startsWith(This that)native{..}=(..)
  startsWith(that, leftOffSet)       @{
    Tests if the substring starting at the specified index starts with the specified prefix.
    characters before the provided index are ignored.
    }@Public method Bool startsWith(This that, I leftOffSet)native{..}=(..)
  subString(that, to)                @Public method This subString(I that, I to)=(..)
  toCamelLow()                       @Public method This toCamelLow()=(..)
  toCamelUp()                        @Public method This toCamelUp()=(..)
  toStartLow()                       @Public method This toStartLow()=(..)
  toStartUp()                        @Public method This toStartUp()=(..)
  trim()                             @{
    Returns a string like the receiver; but with all leading and trailing spaces, new lines and tabs removed.
    }@Public method This trim()native{..}=(..)
  //read methods:
  readEquality(that)                 @{
    Structural equality on strings.
    }@Public read method Bool readEquality(read This that)native{..}=(..)
  size()                             @{
    String size; the number of characters in this string.
    }@Public read method I size()native{..}=(..)
  toS()                              read method This toS()native{..}=(..)
  @Public Alphanumeric={
    //class methods:
    #apply()                           @Public class method This #apply()=(..)
    //imm methods:
    #apply(trait)                      @Public method Trait #apply(Trait trait)[Message.Guard]=(..)
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Fail]=(..)
    #colon0(trait)                     @Public method Trait #colon0(Trait trait)[Fail]=(..)
    trait()                            @Public method Trait trait()=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [Message, HasToS, Message.Guard]
      //class methods:
      #apply(text, cause)                class method mut This #apply(This2 text, Message.OptMessage cause)=(..)
      #apply(that)                       class method mut This #apply(This2 that)=(..)
      #from(stringLiteral)               class method This #from(StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
      with(cause)                        method This with(Message cause)=(..)
      //read methods:
      cause()                            read method Message.OptMessage cause()=(..)
      text()                             read method This2 text()=(..)
      toS()                              read method This2 toS()=(..)
      //mut methods:
      cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
      text(that)                         mut method Void text(This2 that)=(..)
      }
    }
  @Public Chariterator={
    [HasToS]
    //read methods:
    #elem#default(that)                @Public read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    @Public read method This1 #elem#imm(I that)=(..)
    #if()                              @Public read method Bool #if()=(..)
    #startIndex()                      @Public read method I #startIndex()=(..)
    toS()                              read method This1 toS()=(..)
    //lent methods:
    #iterator()                        @Public lent method lent This #iterator()=(..)
    //mut methods:
    #apply()                           @Public mut method This1 #apply()=(..)
    #hasElem(that)                     @Public mut method Collection.IteratorCompose #hasElem(I that)=(..)
    }
  @Public List={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(This1 right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(This1 right)=(..)
    #plus1(left)                       method This #plus1(This1 left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(This1 left)=(..)
    with(right)                        method This with(This1 right)=(..)
    with(that, val)                    method This with(I that, This1 val)=(..)
    withAlso(left)                     method This withAlso(This1 left)=(..)
    withAlso(right)                    method This withAlso(This1 right)=(..)
    withAlso(that, val)                method This withAlso(I that, This1 val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read This1 left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read This1 right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read This1 val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   read method read This1 #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read This1 that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read This1 that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read This1 right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method This1 left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read This1 readLeft()=(..)
    readRight()                        read method read This1 readRight()=(..)
    readVal(that)                      read method read This1 readVal(I that)native{..}=(..)
    right()                            read method This1 right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method This1 toS()=(..)
    val(that)                          read method This1 val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut This1 left)=(..)
    #add(right)                        mut method Void #add(mut This1 right)=(..)
    #add(that)                         mut method Void #add(mut This1 that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut This1 val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut This1 #elem#mut(I that)=(..)
    #left()                            mut method mut This1 #left()=(..)
    #left(that)                        mut method Void #left(mut This1 that)=(..)
    #right()                           mut method mut This1 #right()=(..)
    #right(that)                       mut method Void #right(mut This1 that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut This1 val)native{..}=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut This1 mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(This1 that)=(..)
    #update#default(that, val)         mut method This1 #update#default(I that, This1 val)=(..)
    #update#imm(that, val)             mut method This1 #update#imm(I that, This1 val)=(..)
    #update#mut(that, val)             mut method mut This1 #update#mut(I that, mut This1 val)=(..)
    #val(that)                         mut method mut This1 #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(This1 left)=(..)
    add(right)                         mut method Void add(This1 right)=(..)
    add(that)                          mut method Void add(This1 that)=(..)
    add(that, val)                     mut method Void add(I that, This1 val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(This1 that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read This1 left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read This1 right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read This1 val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(This1 that)=(..)
    set(that, val)                     mut method Void set(I that, This1 val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method This2 #elem#default(I that)=(..)
      #elem#imm(that)                    read method This2 #elem#imm(I that)=(..)
      #elem#read(that)                   read method read This2 #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut This2 #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method This2 #update#default(I that, This2 val)=(..)
      #update#imm(that, val)             mut method This2 #update#imm(I that, This2 val)=(..)
      #update#mut(that, val)             mut method mut This2 #update#mut(I that, mut This2 val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  @Public Map={
    [HasToS]
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    #apply(squareBuilder)              @Public class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               @Public class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   @Public class method mut This #squareBuilder()=(..)
    empty()                            @Public class method mut This empty()=(..)
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    immNorm()                          @Public method This immNorm()=(..)
    //read methods:
    #elem#default(that)                @Public read method Entry #elem#default(I that)=(..)
    #elem#imm(that)                    @Public read method Entry #elem#imm(I that)=(..)
    #elem#read(that)                   @Public read method read Entry #elem#read(I that)=(..)
    #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        @Public read method read This #iterator()=(..)
    #startIndex()                      @Public read method I #startIndex()=(..)
    entry(that)                        @Public read method read Entry entry(I that)=(..)
    immEntry(that)                     @Public read method Entry immEntry(I that)=(..)
    isEmpty()                          @Public read method Bool isEmpty()=(..)
    isMutVal(that)                     @Public read method Bool isMutVal(I that)=(..)
    key(that)                          @Public read method This1 key(I that)=(..)
    readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
    readVal(key)                       @Public read method read Opt readVal(This1 key)=(..)
    readVal(that)                      @Public read method read This1 readVal(I that)=(..)
    size()                             @Public read method I size()=(..)
    toS()                              @Public read method This1 toS()=(..)
    val(key)                           @Public read method Opt val(This1 key)=(..)
    val(that)                          @Public read method This1 val(I that)=(..)
    vals()                             @Public read method read This vals()=(..)
    //mut methods:
    #apply(that)                       @Public mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    @Public mut method mut Entry #elem#mut(I that)=(..)
    #entry(that)                       @Public mut method mut Entry #entry(I that)=(..)
    #put(key, val)                     @Public mut method Void #put(This1 key, mut This1 val)=(..)
    #squareAdd(key, mutVal)            @Public mut method Void #squareAdd(This1 key, mut This1 mutVal)=(..)
    #squareAdd(key, val)               @Public mut method Void #squareAdd(This1 key, This1 val)=(..)
    #val(key)                          @Public mut method mut Opt #val(This1 key)=(..)
    #val(that)                         @Public mut method mut This1 #val(I that)=(..)
    #vals()                            @Public mut method mut This #vals()=(..)
    #varIterator()                     @Public mut method mut This #varIterator()=(..)
    put(key, val)                      @Public mut method Void put(This1 key, This1 val)=(..)
    remove(key)                        @Public mut method Void remove(This1 key)=(..)
    @Public Entry={
      [HasToS]
      //class methods:
      #apply(key, val)                   class method mut This #apply(fwd imm This2 key, fwd mut This2 val)=(..)
      #immK(key, val)                    class method This #immK(This2 key, This2 val)=(..)
      readEntry(key, val)                class method read This readEntry(This2 key, read This2 val)=(..)
      //imm methods:
      #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
      norm()                             method This norm()=(..)
      with(key)                          method This with(This2 key)=(..)
      with(val)                          method This with(This2 val)=(..)
      //read methods:
      immClone()                         read method This immClone()=(..)
      key()                              read method This2 key()=(..)
      readEquality(that)                 read method Bool readEquality(read This that)=(..)
      toS()                              read method This2 toS()=(..)
      val()                              read method read This2 val()=(..)
      //mut methods:
      #val()                             mut method mut This2 #val()=(..)
      capsuleClone()                     mut method capsule This capsuleClone()=(..)
      }
    }
  @Public Opt={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(that)                       class method mut This #apply(fwd mut This1 that)native{..}=(..)
    equals(a, b)                       class method Bool equals(read This1 a, read This1 b)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    //read methods:
    #bang0()                           read method Bool #bang0()=(..)
    #if()                              read method Bool #if()native{..}=(..)
    #in1(that)                         read method Bool #in1(read This1 that)=(..)
    allEq(that)                        read method Bool allEq(read This that)=(..)
    contains(that)                     read method Bool contains(read This1 that)=(..)
    isPresent()                        read method Bool isPresent()=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    toS()                              read method This1 toS()=(..)
    val()                              read method read This1 val()native{..}=(..)
    val(orElse)                        read method read This1 val(read This1 orElse)=(..)
    //mut methods:
    #val()                             mut method mut This1 #val()native{..}=(..)
    #val(orElse)                       mut method mut This1 #val(mut This1 orElse)=(..)
    }
  @Public ParseError={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(This1 that)native{..}=(..)
    #from(stringLiteral)               class method This #from(StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method This1 text()native{..}=(..)
    toS()                              read method This1 toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(This1 that)native{..}=(..)
    }
  @Public Set={
    [HasToS]
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    #apply(squareBuilder)              @Public class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               @Public class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   @Public class method mut This #squareBuilder()=(..)
    empty()                            @Public class method mut This empty()=(..)
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    //read methods:
    #elem#default(that)                @Public read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    @Public read method This1 #elem#imm(I that)=(..)
    #elem#read(that)                   @Public read method This1 #elem#read(I that)=(..)
    #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @Public read method Bool #in1(This1 that)=(..)
    #iterator()                        @Public read method read This #iterator()=(..)
    #startIndex()                      @Public read method I #startIndex()=(..)
    contains(that)                     @Public read method Bool contains(This1 that)=(..)
    isEmpty()                          @Public read method Bool isEmpty()=(..)
    readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
    size()                             @Public read method I size()=(..)
    toS()                              @Public read method This1 toS()=(..)
    val(that)                          @Public read method This1 val(I that)=(..)
    vals()                             @Public read method read This vals()=(..)
    //mut methods:
    #apply(that)                       @Public mut method mut This #apply(Void that)=(..)
    #squareAdd(that)                   @Public mut method Void #squareAdd(This1 that)=(..)
    #vals()                            @Public mut method mut This #vals()=(..)
    add(that)                          @Public mut method Void add(This1 that)=(..)
    remove(that)                       @Public mut method Void remove(This1 that)=(..)
    }
  @Public Spliterator={
    [HasToS]
    //read methods:
    #elem#default(that)                @Public read method This1 #elem#default(I that)=(..)
    #elem#imm(that)                    @Public read method This1 #elem#imm(I that)=(..)
    #if()                              @Public read method Bool #if()=(..)
    #startIndex()                      @Public read method I #startIndex()=(..)
    toS()                              read method This1 toS()=(..)
    //lent methods:
    #iterator()                        @Public lent method lent This #iterator()=(..)
    //mut methods:
    #apply()                           @Public mut method This1 #apply()=(..)
    #hasElem(that)                     @Public mut method Collection.IteratorCompose #hasElem(I that)=(..)
    }
  @Public StringBuilder={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #stringLiteralBuilder()            class method mut This #stringLiteralBuilder()=(..)
    //read methods:
    toS()                              read method This1 toS()native{..}=(..)
    //mut methods:
    #apply(that)                       mut method This1 #apply(Void that)=(..)
    #d0()                              mut method Void #d0()native{..}=(..)
    #d1()                              mut method Void #d1()native{..}=(..)
    #d2()                              mut method Void #d2()native{..}=(..)
    #d3()                              mut method Void #d3()native{..}=(..)
    #d4()                              mut method Void #d4()native{..}=(..)
    #d5()                              mut method Void #d5()native{..}=(..)
    #d6()                              mut method Void #d6()native{..}=(..)
    #d7()                              mut method Void #d7()native{..}=(..)
    #d8()                              mut method Void #d8()native{..}=(..)
    #d9()                              mut method Void #d9()native{..}=(..)
    #la()                              mut method Void #la()native{..}=(..)
    #lb()                              mut method Void #lb()native{..}=(..)
    #lc()                              mut method Void #lc()native{..}=(..)
    #ld()                              mut method Void #ld()native{..}=(..)
    #le()                              mut method Void #le()native{..}=(..)
    #lf()                              mut method Void #lf()native{..}=(..)
    #lg()                              mut method Void #lg()native{..}=(..)
    #lh()                              mut method Void #lh()native{..}=(..)
    #li()                              mut method Void #li()native{..}=(..)
    #lj()                              mut method Void #lj()native{..}=(..)
    #lk()                              mut method Void #lk()native{..}=(..)
    #ll()                              mut method Void #ll()native{..}=(..)
    #lm()                              mut method Void #lm()native{..}=(..)
    #ln()                              mut method Void #ln()native{..}=(..)
    #lo()                              mut method Void #lo()native{..}=(..)
    #lp()                              mut method Void #lp()native{..}=(..)
    #lq()                              mut method Void #lq()native{..}=(..)
    #lr()                              mut method Void #lr()native{..}=(..)
    #ls()                              mut method Void #ls()native{..}=(..)
    #lt()                              mut method Void #lt()native{..}=(..)
    #lu()                              mut method Void #lu()native{..}=(..)
    #lv()                              mut method Void #lv()native{..}=(..)
    #lw()                              mut method Void #lw()native{..}=(..)
    #lx()                              mut method Void #lx()native{..}=(..)
    #ly()                              mut method Void #ly()native{..}=(..)
    #lz()                              mut method Void #lz()native{..}=(..)
    #sand()                            mut method Void #sand()native{..}=(..)
    #sat()                             mut method Void #sat()native{..}=(..)
    #sbackSlash()                      mut method Void #sbackSlash()native{..}=(..)
    #sbang()                           mut method Void #sbang()native{..}=(..)
    #scCurly()                         mut method Void #scCurly()native{..}=(..)
    #scRound()                         mut method Void #scRound()native{..}=(..)
    #scSquare()                        mut method Void #scSquare()native{..}=(..)
    #scolon()                          mut method Void #scolon()native{..}=(..)
    #scomma()                          mut method Void #scomma()native{..}=(..)
    #sdQuote()                         mut method Void #sdQuote()native{..}=(..)
    #sdivide()                         mut method Void #sdivide()native{..}=(..)
    #sdollar()                         mut method Void #sdollar()native{..}=(..)
    #sdot()                            mut method Void #sdot()native{..}=(..)
    #sequal()                          mut method Void #sequal()native{..}=(..)
    #shQuote()                         mut method Void #shQuote()native{..}=(..)
    #shash()                           mut method Void #shash()native{..}=(..)
    #shat()                            mut method Void #shat()native{..}=(..)
    #sleft()                           mut method Void #sleft()native{..}=(..)
    #sless()                           mut method Void #sless()native{..}=(..)
    #snewLine()                        mut method Void #snewLine()native{..}=(..)
    #soCurly()                         mut method Void #soCurly()native{..}=(..)
    #soRound()                         mut method Void #soRound()native{..}=(..)
    #soSquare()                        mut method Void #soSquare()native{..}=(..)
    #sor()                             mut method Void #sor()native{..}=(..)
    #spercent()                        mut method Void #spercent()native{..}=(..)
    #splus()                           mut method Void #splus()native{..}=(..)
    #sqMark()                          mut method Void #sqMark()native{..}=(..)
    #sright()                          mut method Void #sright()native{..}=(..)
    #ssQuote()                         mut method Void #ssQuote()native{..}=(..)
    #ssemicolon()                      mut method Void #ssemicolon()native{..}=(..)
    #sspace()                          mut method Void #sspace()native{..}=(..)
    #stab()                            mut method Void #stab()native{..}=(..)
    #stilde()                          mut method Void #stilde()native{..}=(..)
    #stimes()                          mut method Void #stimes()native{..}=(..)
    #stringAddAll(that)                mut method Void #stringAddAll(mut This that)=(..)
    #stringAddExpr(that)               mut method Void #stringAddExpr(read HasToS that)=(..)
    #sunderscore()                     mut method Void #sunderscore()native{..}=(..)
    #uA()                              mut method Void #uA()native{..}=(..)
    #uB()                              mut method Void #uB()native{..}=(..)
    #uC()                              mut method Void #uC()native{..}=(..)
    #uD()                              mut method Void #uD()native{..}=(..)
    #uE()                              mut method Void #uE()native{..}=(..)
    #uF()                              mut method Void #uF()native{..}=(..)
    #uG()                              mut method Void #uG()native{..}=(..)
    #uH()                              mut method Void #uH()native{..}=(..)
    #uI()                              mut method Void #uI()native{..}=(..)
    #uJ()                              mut method Void #uJ()native{..}=(..)
    #uK()                              mut method Void #uK()native{..}=(..)
    #uL()                              mut method Void #uL()native{..}=(..)
    #uM()                              mut method Void #uM()native{..}=(..)
    #uN()                              mut method Void #uN()native{..}=(..)
    #uO()                              mut method Void #uO()native{..}=(..)
    #uP()                              mut method Void #uP()native{..}=(..)
    #uQ()                              mut method Void #uQ()native{..}=(..)
    #uR()                              mut method Void #uR()native{..}=(..)
    #uS()                              mut method Void #uS()native{..}=(..)
    #uT()                              mut method Void #uT()native{..}=(..)
    #uU()                              mut method Void #uU()native{..}=(..)
    #uV()                              mut method Void #uV()native{..}=(..)
    #uW()                              mut method Void #uW()native{..}=(..)
    #uX()                              mut method Void #uX()native{..}=(..)
    #uY()                              mut method Void #uY()native{..}=(..)
    #uZ()                              mut method Void #uZ()native{..}=(..)
    add(that)                          mut method Void add(read HasToS that)=(..)
    append(that)                       mut method Void append(This1 that)native{..}=(..)
    }
  @AbstractTowel{
    s
    }
  }
@Public System={
  capsuleClone(that)                 @Public class method capsule Any capsuleClone(mut Any that)=(..)
  extractModule(that, name)          @Public class method Trait extractModule(Library that, Name name)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  immClone(that)                     @Public class method Any immClone(read Any that)=(..)
  immEquality(that, and)             @Public class method Bool immEquality(Any that, Any and)=(..)
  immNorm(that)                      @Public class method Any immNorm(Any that)=(..)
  immToString(that)                  @Public class method S immToString(Any that)=(..)
  jarToS(that, fauxName)             @Public class method S jarToS(Library that, S fauxName)=(..)
  mutReferenceEquality(that, and)     @Public class method Bool mutReferenceEquality(mut Any that, read Any and)=(..)
  mutStructuralEquality(that, and)     @Public class method Bool mutStructuralEquality(mut Any that, read Any and)=(..)
  mutToString(that)                  @Public class method S mutToString(mut Any that)=(..)
  towelToS(that, fauxName)           @Public class method S towelToS(Library that, S fauxName)=(..)
  @Public JavaException={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public LibraryNotSelfContained={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public NonDeterministicError={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @AbstractTowel{
    system
    }
  }
@Public Test={
  #from(stringLiteral)               class method WithName #from(S.StringBuilder stringLiteral)=(..)
  hole()                             class method S hole()=(..)
  Condition={
    //class methods:
    #apply(name, cond, message)        class method This #apply(S name, Bool cond, S message)=(..)
    //imm methods:
    #colon1(pos)                       method Void #colon1(Library pos)=(..)
    #from(stringLiteral)               method This #from(S.StringBuilder stringLiteral)=(..)
    //read methods:
    cond()                             read method Bool cond()=(..)
    message()                          read method S message()=(..)
    name()                             read method S name()=(..)
    }
  ExpectedActual={
    //class methods:
    #apply(name, expected, actual, message)     class method This #apply(S name, S expected, S actual, S message)=(..)
    //imm methods:
    #colon1(pos)                       method Void #colon1(Library pos)=(..)
    //read methods:
    actual()                           read method S actual()=(..)
    expected()                         read method S expected()=(..)
    message()                          read method S message()=(..)
    name()                             read method S name()=(..)
    }
  WithName={
    //class methods:
    #apply(name)                       class method This #apply(S name)=(..)
    //imm methods:
    #apply(actual, expected)           method ExpectedActual #apply(read HasToS actual, read HasToS expected)=(..)
    #apply(expected, actual)           method ExpectedActual #apply(read HasToS expected, read HasToS actual)=(..)
    #apply(that)                       method Condition #apply(Bool that)=(..)
    //read methods:
    name()                             read method S name()=(..)
    }
  @AbstractTowel{
    test
    }
  }
@Public Trait={
  //class methods:
  #apply()                           @Public class method This #apply()=(..)
  #apply(that)                       @Public class method This #apply(Library that)=(..)
  delayedCode(that)                  @Public class method Library delayedCode(Library that)[ClassClash, MethodClash]=(..)
  //imm methods:
  #apply(squareBuilder)              @Public method This #apply(read Acc squareBuilder)[InvalidName, InvalidMap, ClassClash, MethodClash]=(..)
  #colon0(lib)                       @Public method This #colon0(Library lib)[ClassClash, MethodClash]=(..)
  #colon0(lifted)                    @Public method This #colon0(class Lifted lifted)[ClassClash, MethodClash]=(..)
  #colon0(trait)                     @Public method This #colon0(This trait)[ClassClash, MethodClash]=(..)
  #plus0(lib)                        @Public method This #plus0(Library lib)[ClassClash, MethodClash]=(..)
  #plus0(lifted)                     @Public method This #plus0(class Lifted lifted)[ClassClash, MethodClash]=(..)
  #plus0(trait)                      @Public method This #plus0(This trait)[ClassClash, MethodClash]=(..)
  #plus1(lib)                        @Public method This #plus1(Library lib)[ClassClash, MethodClash]=(..)
  #plus1(lifted)                     @Public method This #plus1(class Lifted lifted)[ClassClash, MethodClash]=(..)
  #toLibrary()                       @Public method Library #toLibrary()=(..)
  info()                             @Public method Info info()=(..)
  removeUnusedCode()                 @Public method This removeUnusedCode()=(..)
  resetDocs(squareBuilder)           @Public method This resetDocs(mut DocMap squareBuilder)[InvalidName]=(..)
  //read methods:
  code()                             @Public read method Library code()=(..)
  @Public Acc={
    //class methods:
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #apply(that)                       class method mut This #apply(Name.Mapping that)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    //read methods:
    that()                             read method Name.Mapping that()=(..)
    //mut methods:
    #squareAdd(clear)                  mut method Void #squareAdd(Name clear)=(..)
    #squareAdd(clearSingle)            mut method Void #squareAdd(Name clearSingle)=(..)
    #squareAdd(hide)                   mut method Void #squareAdd(Name hide)=(..)
    #squareAdd(ignoreSelfRename)       mut method Void #squareAdd(Name.Mapping ignoreSelfRename)=(..)
    #squareAdd(ignoreSelfRenameSingle)     mut method Void #squareAdd(Name.Mapping ignoreSelfRenameSingle)=(..)
    #squareAdd(single)                 mut method Void #squareAdd(Name.Mapping single)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(Name.Mapping that)=(..)
    that(that)                         mut method Void that(Name.Mapping that)=(..)
    }
  @Public ClassClash={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public ClassOperators={
    #apply()                           class method This1 #apply()=(..)
    }
  @Public DocMap={
    [HasToS]
    //class methods:
    #apply()                           @Public class method mut This #apply()=(..)
    #apply(squareBuilder)              @Public class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               @Public class method Bool #shortCircutSquare()=(..)
    #squareBuilder#resetDocs()         @Public class method mut This #squareBuilder#resetDocs()=(..)
    #squareBuilder()                   @Public class method mut This #squareBuilder()=(..)
    empty()                            @Public class method mut This empty()=(..)
    //imm methods:
    #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
    immNorm()                          @Public method This immNorm()=(..)
    //read methods:
    #elem#default(that)                @Public read method Entry #elem#default(I that)=(..)
    #elem#imm(that)                    @Public read method Entry #elem#imm(I that)=(..)
    #elem#read(that)                   @Public read method read Entry #elem#read(I that)=(..)
    #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        @Public read method read This #iterator()=(..)
    #startIndex()                      @Public read method I #startIndex()=(..)
    entry(that)                        @Public read method read Entry entry(I that)=(..)
    immEntry(that)                     @Public read method Entry immEntry(I that)=(..)
    isEmpty()                          @Public read method Bool isEmpty()=(..)
    isMutVal(that)                     @Public read method Bool isMutVal(I that)=(..)
    key(that)                          @Public read method Name key(I that)=(..)
    readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
    readVal(key)                       @Public read method read OVal readVal(Name key)=(..)
    readVal(that)                      @Public read method read S readVal(I that)=(..)
    resetDocs(that)                    @Public read method Library resetDocs(Library that)[InvalidName]=(..)
    size()                             @Public read method I size()=(..)
    toS()                              @Public read method S toS()=(..)
    val(key)                           @Public read method OVal val(Name key)=(..)
    val(that)                          @Public read method S val(I that)=(..)
    vals()                             @Public read method read This vals()=(..)
    //mut methods:
    #apply(that)                       @Public mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    @Public mut method mut Entry #elem#mut(I that)=(..)
    #entry(that)                       @Public mut method mut Entry #entry(I that)=(..)
    #put(key, val)                     @Public mut method Void #put(Name key, mut S val)=(..)
    #squareAdd(key, mutVal)            @Public mut method Void #squareAdd(Name key, mut S mutVal)=(..)
    #squareAdd(key, val)               @Public mut method Void #squareAdd(Name key, S val)=(..)
    #val(key)                          @Public mut method mut OVal #val(Name key)=(..)
    #val(that)                         @Public mut method mut S #val(I that)=(..)
    #vals()                            @Public mut method mut This #vals()=(..)
    #varIterator()                     @Public mut method mut This #varIterator()=(..)
    put(key, val)                      @Public mut method Void put(Name key, S val)=(..)
    remove(key)                        @Public mut method Void remove(Name key)=(..)
    @Public Entry={
      [HasToS]
      //class methods:
      #apply(key, val)                   class method mut This #apply(fwd imm Name key, fwd mut S val)=(..)
      #immK(key, val)                    class method This #immK(Name key, S val)=(..)
      readEntry(key, val)                class method read This readEntry(Name key, read S val)=(..)
      //imm methods:
      #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
      norm()                             method This norm()=(..)
      with(key)                          method This with(Name key)=(..)
      with(val)                          method This with(S val)=(..)
      //read methods:
      immClone()                         read method This immClone()=(..)
      key()                              read method Name key()=(..)
      readEquality(that)                 read method Bool readEquality(read This that)=(..)
      toS()                              read method S toS()=(..)
      val()                              read method read S val()=(..)
      //mut methods:
      #val()                             mut method mut S #val()=(..)
      capsuleClone()                     mut method capsule This capsuleClone()=(..)
      }
    @Public OVal={
      [HasToS]
      //class methods:
      #apply()                           class method mut This #apply()=(..)
      #apply(that)                       class method mut This #apply(fwd mut S that)native{..}=(..)
      equals(a, b)                       class method Bool equals(read S a, read S b)=(..)
      //imm methods:
      #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
      //read methods:
      #bang0()                           read method Bool #bang0()=(..)
      #if()                              read method Bool #if()native{..}=(..)
      #in1(that)                         read method Bool #in1(read S that)=(..)
      allEq(that)                        read method Bool allEq(read This that)=(..)
      contains(that)                     read method Bool contains(read S that)=(..)
      isPresent()                        read method Bool isPresent()=(..)
      readEquality(that)                 read method Bool readEquality(read This that)=(..)
      toS()                              read method S toS()=(..)
      val()                              read method read S val()native{..}=(..)
      val(orElse)                        read method read S val(read S orElse)=(..)
      //mut methods:
      #val()                             mut method mut S #val()native{..}=(..)
      #val(orElse)                       mut method mut S #val(mut S orElse)=(..)
      }
    }
  @Public InvalidMap={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public InvalidName={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public LiftS={
    #apply(that)                       class method This1 #apply(S that)=(..)
    TraitS={
      [Lifted]
      #apply()                           class method This2 #apply()=(..)
      #apply(squareBuilder)              class method This2 #apply(mut Acc squareBuilder)[InvalidName, InvalidMap, ClassClash, MethodClash]=(..)
      #plus0(lib)                        class method This2 #plus0(Library lib)[ClassClash, MethodClash]=(..)
      #plus1(lib)                        class method This2 #plus1(Library lib)[ClassClash, MethodClash]=(..)
      code()                             class method Library code()=(..)
      info()                             class method Info info()=(..)
      resetDocs(squareBuilder)           class method This2 resetDocs(mut DocMap squareBuilder)[InvalidName]=(..)
      ClassOperators={
        #apply()                           class method This3 #apply()=(..)
        }
      }
    }
  @Public Lifted={
    interface
    #apply()                           class method This1 #apply()
    #apply(squareBuilder)              class method This1 #apply(mut Acc squareBuilder)[InvalidName, InvalidMap, ClassClash, MethodClash]
    #plus0(lib)                        class method This1 #plus0(Library lib)[ClassClash, MethodClash]
    #plus1(lib)                        class method This1 #plus1(Library lib)[ClassClash, MethodClash]
    code()                             class method Library code()
    info()                             class method Info info()
    resetDocs(squareBuilder)           class method This1 resetDocs(mut DocMap squareBuilder)[InvalidName]
    }
  @Public MethodClash={
    [HasToS, Message, Message.Guard]
    //class methods:
    #apply()                           class method This #apply()=(..)
    #apply(that)                       class method mut This #apply(S that)native{..}=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method Message #whoopsed(Library atPos)=(..)
    //read methods:
    text()                             read method S text()native{..}=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    text(that)                         mut method Void text(S that)native{..}=(..)
    }
  @Public NativeSlaveRename={
    #apply(that, oldName, newName)     @Public class method Library #apply(Library that, S oldName, S newName)[InvalidName]=(..)
    }
  @AbstractTowel{
    trait
    }
  }
@Public Url={
  [HasToS]
  //class methods:
  #apply(string)                     @Public class method This #apply(S string)=(..)
  #from(stringLiteral)               @Public@Cache.Call class method This #from(S.StringBuilder stringLiteral)=(..)
  //read methods:
  toS()                              read method S toS()=(..)
  @AbstractTowel{
    url
    }
  }
@Public X={
  [Message, HasToS, Message.Assert]
  //class methods:
  #apply(squareBuilder)              class method Void #apply(mut Checks squareBuilder)=(..)
  #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
  #apply(that)                       class method mut This #apply(S that)=(..)
  #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
  #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
  #squareBuilder()                   class method mut Checks #squareBuilder()=(..)
  introMsg()                         class method S introMsg()=(..)
  raiseError(msg)                    class method Void raiseError(S msg)=(..)
  //imm methods:
  #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
  with(cause)                        method This with(Message cause)=(..)
  //read methods:
  cause()                            read method Message.OptMessage cause()=(..)
  text()                             read method S text()=(..)
  toS()                              read method S toS()=(..)
  //mut methods:
  cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
  text(that)                         mut method Void text(S that)=(..)
  Check={
    [HasToS]
    //class methods:
    #apply(res, msg)                   class method This #apply(fwd imm Bool res, fwd imm S msg)=(..)
    #immK(res, msg)                    class method This #immK(Bool res, S msg)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    norm()                             method This norm()=(..)
    with(msg)                          method This with(S msg)=(..)
    with(res)                          method This with(Bool res)=(..)
    //read methods:
    immClone()                         read method This immClone()=(..)
    msg()                              read method S msg()=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    res()                              read method Bool res()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    capsuleClone()                     mut method capsule This capsuleClone()=(..)
    }
  Checks={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
    #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut This #squareBuilder()=(..)
    equals(a, b)                       class method Bool equals(read Check a, read Check b)=(..)
    //imm methods:
    #bangequal0(that)                  @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }method Bool #equalequal0(This that)=(..)
    #minus0(right)                     @{
      Wither
      Returns the receiver but without all the elements equal to 'right'
      }method This #minus0(Check right)=(..)
    #minusminus0(right)                @{
      Wither
      Returns the receiver but without all the elements contained in the list 'right'
      }method This #minusminus0(This right)=(..)
    #plus0(right)                      method This #plus0(Check right)=(..)
    #plus1(left)                       method This #plus1(Check left)=(..)
    #plusplus0(right)                  method This #plusplus0(This right)=(..)
    immNorm()                          method This immNorm()=(..)
    with(left)                         method This with(Check left)=(..)
    with(right)                        method This with(Check right)=(..)
    with(that, val)                    method This with(I that, Check val)=(..)
    withAlso(left)                     method This withAlso(Check left)=(..)
    withAlso(right)                    method This withAlso(Check right)=(..)
    withAlso(that, val)                method This withAlso(I that, Check val)=(..)
    without(left)                      @{
      Wither
      Returns the receiver but without the leftmost element equal to 'val'
      }method This without(read Check left)=(..)
    without(right)                     @{
      Wither
      Returns the receiver but without the rightmost element equal to 'val'
      }method This without(read Check right)=(..)
    without(that)                      method This without(I that)=(..)
    withoutAll(val)                    @{
      Wither
      Returns the receiver but without all the elements equal to 'val'
      }method This withoutAll(read Check val)=(..)
    withoutLeft()                      method This withoutLeft()=(..)
    withoutRight()                     method This withoutRight()=(..)
    //read methods:
    #elem#default(that)                read method Check #elem#default(I that)=(..)
    #elem#imm(that)                    read method Check #elem#imm(I that)=(..)
    #elem#read(that)                   read method read Check #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #in1(that)                         @{
      Predicate
      True if the element is contained in the List.
      }read method Bool #in1(read Check that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    allEq(that)                        @{
      Predicate
      returns true if all the elements in 'this' are individually 
      This.equals(a,b) to the corresponding element in 'that'.
      This can be different from '==' or 'readEquality': they just use system equality.
      If the elements have a 'readEquality' method, that is used
      On default This.equals(a,b) will use an available equality predicate visible on the element; 
      prioritizing in the following order:
      'allEq', 'readEquality' and '=='.
      If none is present, 'System.immEquality' is used instead.
      }read method Bool allEq(read This that)=(..)
    clone()                            read method capsule This clone()=(..)
    contains(that)                     @{
      Predicate
      True if the element is contained in the List.
      }read method Bool contains(read Check that)=(..)
    indexOf(left)                      @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the leftmost occurrence
      of 'left' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read Check left)=(..)
    indexOf(right)                     @{
      Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
      The result is the index of the rightmost occurrence
      of 'right' in the list according to 'This.equals(a,b)'
      }read method I indexOf(read Check right)=(..)
    isEmpty()                          read method Bool isEmpty()native{..}=(..)
    isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
    left()                             read method Check left()=(..)
    readEquality(that)                 @{
      Predicate
      Delegates to 'System.immEquality'.
      Look at 'allEq' for more flexible equivalence checks.
      }read method Bool readEquality(read This that)=(..)
    readLeft()                         read method read Check readLeft()=(..)
    readRight()                        read method read Check readRight()=(..)
    readVal(that)                      read method read Check readVal(I that)native{..}=(..)
    right()                            read method Check right()=(..)
    size()                             read method I size()native{..}=(..)
    toS()                              read method S toS()=(..)
    val(that)                          read method Check val(I that)native{..}=(..)
    vals()                             read method read This vals()=(..)
    vals(that)                         read method read Iterator vals(I that)=(..)
    vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
    vals(to)                           read method read Iterator vals(I to)=(..)
    //mut methods:
    #add(left)                         mut method Void #add(mut Check left)=(..)
    #add(right)                        mut method Void #add(mut Check right)=(..)
    #add(that)                         mut method Void #add(mut Check that)=(..)
    #add(that, val)                    mut method Void #add(I that, mut Check val)native{..}=(..)
    #apply(that)                       mut method mut This #apply(Void that)=(..)
    #elem#mut(that)                    mut method mut Check #elem#mut(I that)=(..)
    #left()                            mut method mut Check #left()=(..)
    #left(that)                        mut method Void #left(mut Check that)=(..)
    #right()                           mut method mut Check #right()=(..)
    #right(that)                       mut method Void #right(mut Check that)=(..)
    #set(that, val)                    mut method Void #set(I that, mut Check val)native{..}=(..)
    #squareAdd(actual, expected)       mut method Void #squareAdd(Any actual, Any expected)=(..)
    #squareAdd(expected, actual)       mut method Void #squareAdd(Any expected, Any actual)=(..)
    #squareAdd(mutVal)                 mut method Void #squareAdd(mut Check mutVal)=(..)
    #squareAdd(that)                   mut method Void #squareAdd(Bool that)=(..)
    #squareAdd(that, msg)              mut method Void #squareAdd(Bool that, S msg)=(..)
    #update#default(that, val)         mut method Check #update#default(I that, Check val)=(..)
    #update#imm(that, val)             mut method Check #update#imm(I that, Check val)=(..)
    #update#mut(that, val)             mut method mut Check #update#mut(I that, mut Check val)=(..)
    #val(that)                         mut method mut Check #val(I that)native{..}=(..)
    #vals()                            mut method mut This #vals()=(..)
    #vals(that)                        mut method mut Iterator #vals(I that)=(..)
    #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
    #vals(to)                          mut method mut Iterator #vals(I to)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    add(left)                          mut method Void add(Check left)=(..)
    add(right)                         mut method Void add(Check right)=(..)
    add(that)                          mut method Void add(Check that)=(..)
    add(that, val)                     mut method Void add(I that, Check val)native{..}=(..)
    clear()                            mut method Void clear()=(..)
    left(that)                         mut method Void left(Check that)=(..)
    remove(left)                       @{
      Mutator 
      Removes from the list the leftmost element equal to 'left'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
      }mut method Void remove(read Check left)=(..)
    remove(right)                      @{
      Mutator 
      Removes from the list the rightmost element equal to 'right'.
      It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
      }mut method Void remove(read Check right)=(..)
    remove(that)                       mut method Void remove(I that)native{..}=(..)
    removeAll(val)                     @{
      Mutator 
      Removes from the list all the elements equal to 'val'.
      It relies on 'This.equals(a,b)'  
      }mut method Void removeAll(read Check val)=(..)
    removeLeft()                       mut method Void removeLeft()=(..)
    removeRight()                      mut method Void removeRight()=(..)
    right(that)                        mut method Void right(Check that)=(..)
    set(that, val)                     mut method Void set(I that, Check val)native{..}=(..)
    Iterator={
      //class methods:
      #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)=(..)
      //read methods:
      #elem#default(that)                read method Check #elem#default(I that)=(..)
      #elem#imm(that)                    read method Check #elem#imm(I that)=(..)
      #elem#read(that)                   read method read Check #elem#read(I that)=(..)
      #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
      #iterator()                        read method read This #iterator()=(..)
      #startIndex()                      read method I #startIndex()=(..)
      end()                              read method I end()=(..)
      list()                             read method read This1 list()=(..)
      start()                            read method I start()=(..)
      //mut methods:
      #elem#mut(that)                    mut method mut Check #elem#mut(I that)=(..)
      #list()                            mut method mut This1 #list()=(..)
      #update#default(that, val)         mut method Check #update#default(I that, Check val)=(..)
      #update#imm(that, val)             mut method Check #update#imm(I that, Check val)=(..)
      #update#mut(that, val)             mut method mut Check #update#mut(I that, mut Check val)=(..)
      #varIterator()                     mut method mut This #varIterator()=(..)
      }
    }
  Condition={
    //class methods:
    #apply()                           @Public class method This #apply()=(..)
    //imm methods:
    #apply(trait)                      @Public method Trait #apply(Trait trait)[Message.Guard]=(..)
    #colon0(lib)                       @Public method Library #colon0(Library lib)[Fail]=(..)
    #colon0(trait)                     @Public method Trait #colon0(Trait trait)[Fail]=(..)
    trait()                            @Public method Trait trait()=(..)
    @Public ClassOperators={
      #apply()                           class method This1 #apply()=(..)
      }
    @Public Fail={
      [Message, HasToS, Message.Guard]
      //class methods:
      #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
      #apply(that)                       class method mut This #apply(S that)=(..)
      #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
      //imm methods:
      #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
      with(cause)                        method This with(Message cause)=(..)
      //read methods:
      cause()                            read method Message.OptMessage cause()=(..)
      text()                             read method S text()=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
      text(that)                         mut method Void text(S that)=(..)
      }
    }
  EnableAssertions={
    #apply()                           class method Bool #apply()=(..)
    }
  Guarded={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(squareBuilder)              class method Void #apply(mut Checks squareBuilder)=(..)
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut Checks #squareBuilder()=(..)
    introMsg()                         class method S introMsg()=(..)
    raiseError(msg)                    class method Void raiseError(S msg)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  Pre={
    [Message, HasToS, Message.Assert]
    //class methods:
    #apply(squareBuilder)              class method Void #apply(mut Checks squareBuilder)=(..)
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)=(..)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
    #squareBuilder()                   class method mut Checks #squareBuilder()=(..)
    introMsg()                         class method S introMsg()=(..)
    raiseError(msg)                    class method Void raiseError(S msg)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()=(..)
    text()                             read method S text()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)=(..)
    text(that)                         mut method Void text(S that)=(..)
    }
  @AbstractTowel{
    x
    }
  }
]]></pre>

</p><p id="Collection">
</p><div style="break-after:page"></div><h1> Collection </h1> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to create many kinds of collections.
Here you can see examples of collections of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The following code: 
<pre class="l42Big"><![CDATA[
Point = Data:{Num x, Num y}
Person = Data:{S name var Point location}

ListPerson = Collection.list(Person)
SetPerson  = Collection.set(Person)
MapSPerson = Collection.map(key=S val=Person)
OptPerson  = Collection.optional(Person)
MatrixPerson  = Collection.matrix(ListPerson, row=10I, col=20I)
LinkeListPerson = Collection.linkedList(Person)
]]></pre>
Would produce the following:
<pre class="l42BigFolded"><![CDATA[
LinkeListPerson={
  interface
  #iterator()                        @Public read method Iterator #iterator()
  #plusplus0(that)                   @Public read method read This #plusplus0(read This that)
  #startIndex()                      @Public read method read This #startIndex()
  isEmpty()                          @Public read method Bool isEmpty()
  pop()                              @Public read method read This pop()
  push(that)                         @Public read method read This push(read Person that)
  succ()                             @Public read method read This succ()
  top()                              @Public read method read Person top()
  @Public Empty={
    [This1]
    //class methods:
    #apply()                           @Public class method read This1 #apply()=(..)
    //read methods:
    #iterator()                        read method Iterator #iterator()=(..)
    #plusplus0(that)                   read method read This1 #plusplus0(read This1 that)=(..)
    #startIndex()                      read method read This1 #startIndex()=(..)
    isEmpty()                          read method Bool isEmpty()=(..)
    pop()                              read method read This1 pop()=(..)
    push(that)                         read method read This1 push(read Person that)=(..)
    succ()                             read method read This1 succ()=(..)
    top()                              read method read Person top()=(..)
    }
  @Public Iterator={
    //imm methods:
    #elem#default(that)                @Public method read Person #elem#default(read This1 that)=(..)
    //read methods:
    #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(read This1 that)=(..)
    }
  }
ListPerson={
  [HasToS]
  //class methods:
  #apply()                           class method mut This #apply()
  #apply(capacity)                   class method mut This #apply(I capacity)native{..}=(..)
  #apply(squareBuilder)              class method mut This #apply(mut This squareBuilder)=(..)
  #shortCircutSquare()               class method Bool #shortCircutSquare()=(..)
  #squareBuilder()                   class method mut This #squareBuilder()=(..)
  equals(a, b)                       class method Bool equals(read Person a, read Person b)=(..)
  //imm methods:
  #bangequal0(that)                  @{
    Predicate
    Delegates to 'System.immEquality'.
    Look at 'allEq' for more flexible equivalence checks.
    }method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @{
    Predicate
    Delegates to 'System.immEquality'.
    Look at 'allEq' for more flexible equivalence checks.
    }method Bool #equalequal0(This that)=(..)
  #minus0(right)                     @{
    Wither
    Returns the receiver but without all the elements equal to 'right'
    }method This #minus0(Person right)=(..)
  #minusminus0(right)                @{
    Wither
    Returns the receiver but without all the elements contained in the list 'right'
    }method This #minusminus0(This right)=(..)
  #plus0(right)                      method This #plus0(Person right)=(..)
  #plus1(left)                       method This #plus1(Person left)=(..)
  #plusplus0(right)                  method This #plusplus0(This right)=(..)
  immNorm()                          method This immNorm()=(..)
  with(left)                         method This with(Person left)=(..)
  with(right)                        method This with(Person right)=(..)
  with(that, val)                    method This with(I that, Person val)=(..)
  withAlso(left)                     method This withAlso(Person left)=(..)
  withAlso(right)                    method This withAlso(Person right)=(..)
  withAlso(that, val)                method This withAlso(I that, Person val)=(..)
  without(left)                      @{
    Wither
    Returns the receiver but without the leftmost element equal to 'val'
    }method This without(read Person left)=(..)
  without(right)                     @{
    Wither
    Returns the receiver but without the rightmost element equal to 'val'
    }method This without(read Person right)=(..)
  without(that)                      method This without(I that)=(..)
  withoutAll(val)                    @{
    Wither
    Returns the receiver but without all the elements equal to 'val'
    }method This withoutAll(read Person val)=(..)
  withoutLeft()                      method This withoutLeft()=(..)
  withoutRight()                     method This withoutRight()=(..)
  //read methods:
  #elem#default(that)                read method Person #elem#default(I that)=(..)
  #elem#imm(that)                    read method Person #elem#imm(I that)=(..)
  #elem#read(that)                   read method read Person #elem#read(I that)=(..)
  #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
  #in1(that)                         @{
    Predicate
    True if the element is contained in the List.
    }read method Bool #in1(read Person that)=(..)
  #iterator()                        read method read This #iterator()=(..)
  #startIndex()                      read method I #startIndex()=(..)
  allEq(that)                        @{
    Predicate
    returns true if all the elements in 'this' are individually 
    This.equals(a,b) to the corresponding element in 'that'.
    This can be different from '==' or 'readEquality': they just use system equality.
    If the elements have a 'readEquality' method, that is used
    On default This.equals(a,b) will use an available equality predicate visible on the element; 
    prioritizing in the following order:
    'allEq', 'readEquality' and '=='.
    If none is present, 'System.immEquality' is used instead.
    }read method Bool allEq(read This that)=(..)
  clone()                            read method capsule This clone()=(..)
  contains(that)                     @{
    Predicate
    True if the element is contained in the List.
    }read method Bool contains(read Person that)=(..)
  indexOf(left)                      @{
    Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
    The result is the index of the leftmost occurrence
    of 'left' in the list according to 'This.equals(a,b)'
    }read method I indexOf(read Person left)=(..)
  indexOf(right)                     @{
    Old fashion indexOf returning 0..size-1 or -1 to indicate absence. 
    The result is the index of the rightmost occurrence
    of 'right' in the list according to 'This.equals(a,b)'
    }read method I indexOf(read Person right)=(..)
  isEmpty()                          read method Bool isEmpty()native{..}=(..)
  isMutVal(that)                     read method Bool isMutVal(I that)native{..}=(..)
  left()                             read method Person left()=(..)
  readEquality(that)                 @{
    Predicate
    Delegates to 'System.immEquality'.
    Look at 'allEq' for more flexible equivalence checks.
    }read method Bool readEquality(read This that)=(..)
  readLeft()                         read method read Person readLeft()=(..)
  readRight()                        read method read Person readRight()=(..)
  readVal(that)                      read method read Person readVal(I that)native{..}=(..)
  right()                            read method Person right()=(..)
  size()                             read method I size()native{..}=(..)
  toS()                              read method S toS()=(..)
  val(that)                          read method Person val(I that)native{..}=(..)
  vals()                             read method read This vals()=(..)
  vals(that)                         read method read Iterator vals(I that)=(..)
  vals(that, to)                     read method read Iterator vals(I that, I to)=(..)
  vals(to)                           read method read Iterator vals(I to)=(..)
  //mut methods:
  #add(left)                         mut method Void #add(mut Person left)=(..)
  #add(right)                        mut method Void #add(mut Person right)=(..)
  #add(that)                         mut method Void #add(mut Person that)=(..)
  #add(that, val)                    mut method Void #add(I that, mut Person val)native{..}=(..)
  #apply(that)                       mut method mut This #apply(Void that)=(..)
  #elem#mut(that)                    mut method mut Person #elem#mut(I that)=(..)
  #left()                            mut method mut Person #left()=(..)
  #left(that)                        mut method Void #left(mut Person that)=(..)
  #right()                           mut method mut Person #right()=(..)
  #right(that)                       mut method Void #right(mut Person that)=(..)
  #set(that, val)                    mut method Void #set(I that, mut Person val)native{..}=(..)
  #squareAdd(mutVal)                 mut method Void #squareAdd(mut Person mutVal)=(..)
  #squareAdd(that)                   mut method Void #squareAdd(Person that)=(..)
  #update#default(that, val)         mut method Person #update#default(I that, Person val)=(..)
  #update#imm(that, val)             mut method Person #update#imm(I that, Person val)=(..)
  #update#mut(that, val)             mut method mut Person #update#mut(I that, mut Person val)=(..)
  #val(that)                         mut method mut Person #val(I that)native{..}=(..)
  #vals()                            mut method mut This #vals()=(..)
  #vals(that)                        mut method mut Iterator #vals(I that)=(..)
  #vals(that, to)                    mut method mut Iterator #vals(I that, I to)=(..)
  #vals(to)                          mut method mut Iterator #vals(I to)=(..)
  #varIterator()                     mut method mut This #varIterator()=(..)
  add(left)                          mut method Void add(Person left)=(..)
  add(right)                         mut method Void add(Person right)=(..)
  add(that)                          mut method Void add(Person that)=(..)
  add(that, val)                     mut method Void add(I that, Person val)native{..}=(..)
  clear()                            mut method Void clear()=(..)
  left(that)                         mut method Void left(Person that)=(..)
  remove(left)                       @{
    Mutator 
    Removes from the list the leftmost element equal to 'left'.
    It relies on 'This.equals(a,b)' through 'this.indexOf(left)'  
    }mut method Void remove(read Person left)=(..)
  remove(right)                      @{
    Mutator 
    Removes from the list the rightmost element equal to 'right'.
    It relies on 'This.equals(a,b)' through 'this.indexOf(right)'  
    }mut method Void remove(read Person right)=(..)
  remove(that)                       mut method Void remove(I that)native{..}=(..)
  removeAll(val)                     @{
    Mutator 
    Removes from the list all the elements equal to 'val'.
    It relies on 'This.equals(a,b)'  
    }mut method Void removeAll(read Person val)=(..)
  removeLeft()                       mut method Void removeLeft()=(..)
  removeRight()                      mut method Void removeRight()=(..)
  right(that)                        mut method Void right(Person that)=(..)
  set(that, val)                     mut method Void set(I that, Person val)native{..}=(..)
  Iterator={
    //class methods:
    #apply(start, end, list)           class method mut This #apply(I start, I end, fwd mut This1 list)
    //read methods:
    #elem#default(that)                read method Person #elem#default(I that)=(..)
    #elem#imm(that)                    read method Person #elem#imm(I that)=(..)
    #elem#read(that)                   read method read Person #elem#read(I that)=(..)
    #hasElem(that)                     read method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        read method read This #iterator()=(..)
    #startIndex()                      read method I #startIndex()=(..)
    end()                              read method I end()
    list()                             read method read This1 list()
    start()                            read method I start()
    //mut methods:
    #elem#mut(that)                    mut method mut Person #elem#mut(I that)=(..)
    #list()                            mut method mut This1 #list()
    #update#default(that, val)         mut method Person #update#default(I that, Person val)=(..)
    #update#imm(that, val)             mut method Person #update#imm(I that, Person val)=(..)
    #update#mut(that, val)             mut method mut Person #update#mut(I that, mut Person val)=(..)
    #varIterator()                     mut method mut This #varIterator()=(..)
    }
  }
MapSPerson={
  [HasToS]
  //class methods:
  #apply()                           @Public class method mut This #apply()=(..)
  #apply(squareBuilder)              @Public class method mut This #apply(mut This squareBuilder)=(..)
  #shortCircutSquare()               @Public class method Bool #shortCircutSquare()=(..)
  #squareBuilder()                   @Public class method mut This #squareBuilder()=(..)
  empty()                            @Public class method mut This empty()=(..)
  //imm methods:
  #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
  immNorm()                          @Public method This immNorm()=(..)
  //read methods:
  #elem#default(that)                @Public read method Entry #elem#default(I that)=(..)
  #elem#imm(that)                    @Public read method Entry #elem#imm(I that)=(..)
  #elem#read(that)                   @Public read method read Entry #elem#read(I that)=(..)
  #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
  #iterator()                        @Public read method read This #iterator()=(..)
  #startIndex()                      @Public read method I #startIndex()=(..)
  entry(that)                        @Public read method read Entry entry(I that)=(..)
  immEntry(that)                     @Public read method Entry immEntry(I that)=(..)
  isEmpty()                          @Public read method Bool isEmpty()=(..)
  isMutVal(that)                     @Public read method Bool isMutVal(I that)=(..)
  key(that)                          @Public read method S key(I that)=(..)
  readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
  readVal(key)                       @Public read method read OVal readVal(S key)=(..)
  readVal(that)                      @Public read method read Person readVal(I that)=(..)
  size()                             @Public read method I size()=(..)
  toS()                              @Public read method S toS()=(..)
  val(key)                           @Public read method OVal val(S key)=(..)
  val(that)                          @Public read method Person val(I that)=(..)
  vals()                             @Public read method read This vals()=(..)
  //mut methods:
  #apply(that)                       @Public mut method mut This #apply(Void that)=(..)
  #elem#mut(that)                    @Public mut method mut Entry #elem#mut(I that)=(..)
  #entry(that)                       @Public mut method mut Entry #entry(I that)=(..)
  #put(key, val)                     @Public mut method Void #put(S key, mut Person val)=(..)
  #squareAdd(key, mutVal)            @Public mut method Void #squareAdd(S key, mut Person mutVal)=(..)
  #squareAdd(key, val)               @Public mut method Void #squareAdd(S key, Person val)=(..)
  #val(key)                          @Public mut method mut OVal #val(S key)=(..)
  #val(that)                         @Public mut method mut Person #val(I that)=(..)
  #vals()                            @Public mut method mut This #vals()=(..)
  #varIterator()                     @Public mut method mut This #varIterator()=(..)
  put(key, val)                      @Public mut method Void put(S key, Person val)=(..)
  remove(key)                        @Public mut method Void remove(S key)=(..)
  @Public Entry={
    [HasToS]
    //class methods:
    #apply(key, val)                   class method mut This #apply(fwd imm S key, fwd mut Person val)=(..)
    #immK(key, val)                    class method This #immK(S key, Person val)=(..)
    readEntry(key, val)                class method read This readEntry(S key, read Person val)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    norm()                             method This norm()=(..)
    with(key)                          method This with(S key)=(..)
    with(val)                          method This with(Person val)=(..)
    //read methods:
    immClone()                         read method This immClone()=(..)
    key()                              read method S key()=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    toS()                              read method S toS()=(..)
    val()                              read method read Person val()=(..)
    //mut methods:
    #val()                             mut method mut Person #val()=(..)
    capsuleClone()                     mut method capsule This capsuleClone()=(..)
    }
  @Public OVal={
    [HasToS]
    //class methods:
    #apply()                           class method mut This #apply()=(..)
    #apply(that)                       class method mut This #apply(fwd mut Person that)native{..}=(..)
    equals(a, b)                       class method Bool equals(read Person a, read Person b)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    //read methods:
    #bang0()                           read method Bool #bang0()=(..)
    #if()                              read method Bool #if()native{..}=(..)
    #in1(that)                         read method Bool #in1(read Person that)=(..)
    allEq(that)                        read method Bool allEq(read This that)=(..)
    contains(that)                     read method Bool contains(read Person that)=(..)
    isPresent()                        read method Bool isPresent()=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    toS()                              read method S toS()=(..)
    val()                              read method read Person val()native{..}=(..)
    val(orElse)                        read method read Person val(read Person orElse)=(..)
    //mut methods:
    #val()                             mut method mut Person #val()native{..}=(..)
    #val(orElse)                       mut method mut Person #val(mut Person orElse)=(..)
    }
  }
MatrixPerson={
  [HasToS]
  //class methods:
  #apply(default)                    @Public class method mut This #apply(Person default)=(..)
  #apply(mutDefault)                 @Public class method mut This #apply(mut Person mutDefault)=(..)
  #apply(that)                       @Public class method mut This #apply(mut ListPerson that)=(..)
  #immK(that)                        @Public class method This #immK(ListPerson that)=(..)
  dimensions()                       @Public@Cache.Lazy class method Collection.Dimensions dimensions()=(..)
  elemToS(row, col, val)             @Public class method S elemToS(I row, I col, read Person val)=(..)
  //imm methods:
  #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
  with(row, col, val)                @Public method This with(I row, I col, Person val)=(..)
  with(that, val)                    @Public method This with(Coord that, Person val)=(..)
  //read methods:
  #elem#default(that)                @Public read method Person #elem#default(I that)=(..)
  #elem#imm(that)                    @Public read method Person #elem#imm(I that)=(..)
  #elem#read(that)                   @Public read method read Person #elem#read(I that)=(..)
  #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
  #iterator()                        @Public read method read This #iterator()=(..)
  #startIndex()                      @Public read method I #startIndex()=(..)
  allEq(that)                        @Public read method Bool allEq(read This that)=(..)
  asList()                           @Public read method read ListPerson asList()=(..)
  coords()                           @Public read method Iterator coords()=(..)
  readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
  readVal(row, col)                  @Public read method read Person readVal(I row, I col)=(..)
  readVal(that)                      @Public read method read Person readVal(Coord that)=(..)
  toS()                              read method S toS()=(..)
  val(row, col)                      @Public read method Person val(I row, I col)=(..)
  val(that)                          @Public read method Person val(Coord that)=(..)
  vals()                             @Public read method read This vals()=(..)
  //mut methods:
  #elem#mut(that)                    @Public mut method mut Person #elem#mut(I that)=(..)
  #set(row, col, val)                @Public mut method Void #set(I row, I col, mut Person val)=(..)
  #set(that, val)                    @Public mut method Void #set(Coord that, mut Person val)=(..)
  #update#default(that, val)         @Public mut method Person #update#default(I that, Person val)=(..)
  #update#imm(that, val)             @Public mut method Person #update#imm(I that, Person val)=(..)
  #update#mut(that, val)             @Public mut method mut Person #update#mut(I that, mut Person val)=(..)
  #val(row, col)                     @Public mut method mut Person #val(I row, I col)=(..)
  #val(that)                         @Public mut method mut Person #val(Coord that)=(..)
  #vals()                            @Public mut method mut This #vals()=(..)
  #varIterator()                     @Public mut method mut This #varIterator()=(..)
  set(row, col, val)                 @Public mut method Void set(I row, I col, Person val)=(..)
  set(that, val)                     @Public mut method Void set(Coord that, Person val)=(..)
  @Public Coord={
    [HasToS]
    //class methods:
    #apply(index)                      class method This #apply(I index)=(..)
    #apply(row, col)                   class method This #apply(I row, I col)=(..)
    #immK(row, col)                    class method This #immK(I row, I col)=(..)
    invariant(row, col)                class method Void invariant(I row, I col)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    index()                            method I index()=(..)
    norm()                             method This norm()=(..)
    with(col)                          method This with(I col)=(..)
    with(row)                          method This with(I row)=(..)
    //read methods:
    col()                              read method I col()=(..)
    immClone()                         read method This immClone()=(..)
    invariant()                        @Cache.Now read method Void invariant()native{..}=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    row()                              read method I row()=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    capsuleClone()                     mut method capsule This capsuleClone()=(..)
    }
  @Public Iterator={
    //class methods:
    #apply()                           class method This #apply()=(..)
    //imm methods:
    #elem#default(that)                method Coord #elem#default(I that)=(..)
    #hasElem(that)                     method Collection.IteratorCompose #hasElem(I that)=(..)
    #iterator()                        method This #iterator()=(..)
    #startIndex()                      method I #startIndex()=(..)
    }
  }
OptPerson={
  [HasToS]
  //class methods:
  #apply()                           class method mut This #apply()
  #apply(that)                       class method mut This #apply(fwd mut Person that)native{..}=(..)
  equals(a, b)                       class method Bool equals(read Person a, read Person b)=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  //read methods:
  #bang0()                           read method Bool #bang0()=(..)
  #if()                              read method Bool #if()native{..}=(..)
  #in1(that)                         read method Bool #in1(read Person that)=(..)
  allEq(that)                        read method Bool allEq(read This that)=(..)
  contains(that)                     read method Bool contains(read Person that)=(..)
  isPresent()                        read method Bool isPresent()=(..)
  readEquality(that)                 read method Bool readEquality(read This that)=(..)
  toS()                              read method S toS()=(..)
  val()                              read method read Person val()native{..}=(..)
  val(orElse)                        read method read Person val(read Person orElse)=(..)
  //mut methods:
  #val()                             mut method mut Person #val()native{..}=(..)
  #val(orElse)                       mut method mut Person #val(mut Person orElse)=(..)
  }
Person={
  [HasToS]
  //class methods:
  #apply(name, location)             class method mut This #apply(fwd imm S name, fwd imm Point location)=(..)
  #immK(name, location)              class method This #immK(S name, Point location)=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  norm()                             method This norm()=(..)
  with(location)                     method This with(Point location)=(..)
  with(name)                         method This with(S name)=(..)
  //read methods:
  immClone()                         read method This immClone()=(..)
  location()                         read method Point location()=(..)
  name()                             read method S name()=(..)
  readEquality(that)                 read method Bool readEquality(read This that)=(..)
  toS()                              read method S toS()=(..)
  //mut methods:
  capsuleClone()                     mut method capsule This capsuleClone()=(..)
  location(that)                     mut method Void location(Point that)=(..)
  }
Point={
  [HasToS]
  //class methods:
  #apply(x, y)                       class method This #apply(fwd imm Num x, fwd imm Num y)=(..)
  #immK(x, y)                        class method This #immK(Num x, Num y)=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  norm()                             method This norm()=(..)
  with(x)                            method This with(Num x)=(..)
  with(y)                            method This with(Num y)=(..)
  //read methods:
  immClone()                         read method This immClone()=(..)
  readEquality(that)                 read method Bool readEquality(read This that)=(..)
  toS()                              read method S toS()=(..)
  x()                                read method Num x()=(..)
  y()                                read method Num y()=(..)
  //mut methods:
  capsuleClone()                     mut method capsule This capsuleClone()=(..)
  }
SetPerson={
  [HasToS]
  //class methods:
  #apply()                           @Public class method mut This #apply()=(..)
  #apply(squareBuilder)              @Public class method mut This #apply(mut This squareBuilder)=(..)
  #shortCircutSquare()               @Public class method Bool #shortCircutSquare()=(..)
  #squareBuilder()                   @Public class method mut This #squareBuilder()=(..)
  empty()                            @Public class method mut This empty()=(..)
  //imm methods:
  #bangequal0(that)                  @Public method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 @Public method Bool #equalequal0(This that)=(..)
  //read methods:
  #elem#default(that)                @Public read method Person #elem#default(I that)=(..)
  #elem#imm(that)                    @Public read method Person #elem#imm(I that)=(..)
  #elem#read(that)                   @Public read method Person #elem#read(I that)=(..)
  #hasElem(that)                     @Public read method Collection.IteratorCompose #hasElem(I that)=(..)
  #in1(that)                         @Public read method Bool #in1(Person that)=(..)
  #iterator()                        @Public read method read This #iterator()=(..)
  #startIndex()                      @Public read method I #startIndex()=(..)
  contains(that)                     @Public read method Bool contains(Person that)=(..)
  isEmpty()                          @Public read method Bool isEmpty()=(..)
  readEquality(that)                 @Public read method Bool readEquality(read This that)=(..)
  size()                             @Public read method I size()=(..)
  toS()                              @Public read method S toS()=(..)
  val(that)                          @Public read method Person val(I that)=(..)
  vals()                             @Public read method read This vals()=(..)
  //mut methods:
  #apply(that)                       @Public mut method mut This #apply(Void that)=(..)
  #squareAdd(that)                   @Public mut method Void #squareAdd(Person that)=(..)
  #vals()                            @Public mut method mut This #vals()=(..)
  add(that)                          @Public mut method Void add(Person that)=(..)
  remove(that)                       @Public mut method Void remove(Person that)=(..)
  }
]]></pre>

</p><p id="Message">
</p><div style="break-after:page"></div><h1> Message </h1> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to create many kinds of messages.
Here you can see an example of a custom message, with an extra method and 
additionally implementing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message.Guard]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The following code:
<pre class="l42Big"><![CDATA[
KindInformation = Message:{[Message.Guard]
  method S extra()=S"Wow that was a great explanation!"
  }
]]></pre>
Would produce the following:
<pre class="l42BigFolded"><![CDATA[
KindInformation={
  [Message, HasToS, Message.Guard]
  //class methods:
  #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)
  #apply(that)                       class method mut This #apply(S that)=(..)
  #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
  //imm methods:
  #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
  extra()                            method S extra()=(..)
  with(cause)                        method This with(Message cause)=(..)
  //read methods:
  cause()                            read method Message.OptMessage cause()
  text()                             read method S text()
  toS()                              read method S toS()=(..)
  //mut methods:
  cause(that)                        mut method Void cause(Message.OptMessage that)
  text(that)                         mut method Void text(S that)
  }
]]></pre>

        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'>
            <a href="mailto:marco.servetto@gmail.com" rel="me">Contact Us</a> |</li>
            <li style='display:inline;'>
            <a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>
