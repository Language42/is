<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="https://l42.is/css/style.css" media="all"/>
    <script src="https://l42.is/js/ace.js"></script>
    <script src="https://l42.is/js/utils.js"></script>
    <link rel="shortcut icon" href="https://l42.is/css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="https://www.googletagmanager.com/gtag/js?id=G-M0E4M0XH2Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-M0E4M0XH2Z');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-212820693-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-212820693-1');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=AW-10810288706"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'AW-10810288706');
    </script>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='https://l42.is/css/logoBlue.png' alt='42' width='120' height='120'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>

<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90">Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="#Process"> The process library </a></li>

</ol>
</div></div><div class="finishFloat"></div></div>

</p><p id="Process">
</p><div style="break-after:page"></div><h1> The process library </h1> <p>
</p><h2> Importing process and example usage </h2> <p>

The process library allows to run processes from AdamsTowel.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Process.Real.#$of(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> creates a capability object permanently connected with a specific
command and option, but the standard input of the program can be specified by the capability user.
<pre class="l42Big"><![CDATA[
Process = Load:{reuse[L42.is/Process]}
..
  (
  Process pLinux=Process.Real.#$of(\[S"ls";S"-l"])
  res=pLinux.start(input=S"")
  Debug(res.out())
  Debug(res.err())
  catch Process.Fail f Debug(S"oh no!")
  )
]]></pre>

</p><h2> Overview under AdamsTowel </h2> <p>
<pre class="l42BigFolded"><![CDATA[
//class methods:
#$of()                             class method mut This #$of()=(..)
#$token()                          class method S #$token()
name()                             class method S name()
repo()                             class method S repo()
version()                          class method S version()
//mut methods:
deployDocs(that)                   mut method mut DocsBuilder deployDocs(S that)[Process.Fail]=(..)
deployModule(that, nestedName)     mut method Void deployModule(Trait that, Name nestedName)[GW.Fail, Cache.Call.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
deployTowel(that)                  mut method Void deployTowel(Trait that)[GW.Fail, Cache.Call.Fail]=(..)
fs()                               mut method mut Fs fs()=(..)
gw()                               mut method mut GW gw()=(..)
Deploy={
  with(writer)                       class method Library with(class Any writer)[Class.IncoherentClass, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  DeployTrait={
    [Trait.Lifted]
    #apply()                           class method Trait #apply()=(..)
    #apply(squareBuilder)              class method Trait #apply(mut Trait.Acc squareBuilder)[Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
    #plus0(lib)                        class method Trait #plus0(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    #plus1(lib)                        class method Trait #plus1(Library lib)[Trait.ClassClash, Trait.MethodClash]=(..)
    code()                             class method Library code()=(..)
    info()                             class method Info info()=(..)
    resetDocs(squareBuilder)           class method Trait resetDocs(mut Trait.DocMap squareBuilder)[Trait.InvalidName]=(..)
    ClassOperators={
      #apply()                           class method Trait #apply()=(..)
      }
    }
  }
DeployGit={
  jar(that, on, writer)              class method Void jar(Trait that, Url on, mut GW writer)[GW.Fail]=(..)
  module(that, name, on, writer)     class method Void module(Trait that, Name name, Url on, mut GW writer)[GW.Fail, Cache.Call.Fail, Trait.InvalidName, Trait.InvalidMap, Trait.ClassClash, Trait.MethodClash]=(..)
  towel(that, on, writer)            class method Void towel(Trait that, Url on, mut GW writer)[GW.Fail, Cache.Call.Fail]=(..)
  }
DocsBuilder={
  [HasToS]
  //class methods:
  #apply(that, content)              class method mut This #apply(fwd mut This1 that, fwd imm S content)=(..)
  #immK(that, content)               class method This #immK(This1 that, S content)=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  norm()                             method This norm()=(..)
  with(content)                      method This with(S content)=(..)
  with(that)                         method This with(This1 that)=(..)
  //read methods:
  content()                          read method S content()=(..)
  immClone()                         read method This immClone()=(..)
  readEquality(that)                 read method Bool readEquality(read This that)=(..)
  that()                             read method read This1 that()=(..)
  toS()                              read method S toS()=(..)
  //mut methods:
  #that()                            mut method mut This1 #that()=(..)
  #tilde0()                          mut method Void #tilde0()[GW.Fail]=(..)
  capsuleClone()                     mut method capsule This capsuleClone()=(..)
  content(that)                      mut method Void content(S that)=(..)
  overview(that, key)                mut method mut This overview(class Any that, S key)=(..)
  overview(trait, key)               mut method mut This overview(Trait trait, S key)=(..)
  supportFile(localName, destination)     mut method mut This supportFile(Url localName, S destination)[GW.Fail, Fs.Fail]=(..)
  }
Fs={
  interface
  delete(that)                       mut method Void delete(Url that)[Fail]
  makeDirs(that)                     mut method Void makeDirs(Url that)[Fail]
  read(that)                         mut method S read(Url that)[Fail]
  readBase64(that)                   mut method S readBase64(Url that)[Fail]
  write(on, content)                 mut method Void write(Url on, S content)[Fail]
  write(on, contentBase64)           mut method Void write(Url on, S contentBase64)[Fail]
  Fail={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()
    text()                             read method S text()
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)
    text(that)                         mut method Void text(S that)
    }
  Real={
    [This1]
    //class methods:
    #$of()                             @{
      Capability factory.  
      Creates an object connected with the real file system.
      }@Public class method mut This #$of()=(..)
    //mut methods:
    delete(that)                       @{
      Capability method.
      Deletes the file or directory denoted by the @Url 'that'.
      If it denotes a directory, then the directory must be empty in order to be deleted.
      }@Public mut method Void delete(Url that)[Fail]=(..)
    makeDirs(that)                     @{
      Capability method.
      Creates the directory named by the @Url 'that', 
      including any necessary but nonexistent parent directories.
      Note that if this operation fails it may have succeeded in
      creating some of the necessary parent directories.
      }@Public mut method Void makeDirs(Url that)[Fail]=(..)
    read(that)                         @{
      Capability method.
      Reads all the content from the @Url 'that' into the resulting string @S
      Any part of the input that is not directly representable as a character in @S
      is trimmed away.
      }@Public mut method S read(Url that)[Fail]=(..)
    readBase64(that)                   @{
      Capability method.
      Reads all the binary content from the @Url 'that' into the resulting string @S
      The content is encoded as Base64.
      }@Public mut method S readBase64(Url that)[Fail]=(..)
    write(on, content)                 @{
      Capability method.
      It opens the file for writing, creating the file if it doesn't exist,
      or initially truncating an existing regular-file to a size of 0.
      The full @S 'content' is wrote to the file.
      The method ensures that the file is closed after this operation is completed.
      If an error occurs it may do so after the file has been created or truncated,
      or after some bytes have been written to the file.
      }@Public mut method Void write(Url on, S content)[Fail]=(..)
    write(on, contentBase64)           @{
      Capability method.
      Similar to 'write(that content)', but it takes in input binary data 
      represented as a Base64 string, and writes them on the file in binary form. 
      }@Public mut method Void write(Url on, S contentBase64)[Fail]=(..)
    }
  @{
    Url as for the WhatWG URL Standard, where relative urls are allowed
    In particular, if the provided url is relative,
    it is resolved against the current location.
    For example
    "https://google.com/bla/foo" is absolute so is left untouched
    "bla/foo" becomes something like "file:/C:/Users/--/Desktop/--/--/bla/foo"
        Note that "./bla/foo" would resolve exactly as "bla/foo"  
    "/C:/bla/foo" becomes "file:///C:/bla/foo"
        Note that "C:/bla/foo" would not be allowed.
    "/bla/foo" becomes "file:///bla/foo"; that is, starting from the root
    names with spaces or other special characters must be percent encoded, so for example 
    "myFolder/bla%20foo.txt" will point to the file "bla foo.txt" inside "myFolder".
    }
  }
GW={
  [HasToS]
  //class methods:
  #$of(token, message)               class method mut This #$of(S token, S message)=(..)
  #apply(httpRequest, token, message)     class method mut This #apply(fwd mut HttpRequest httpRequest, fwd imm S token, fwd imm S message)=(..)
  #immK(httpRequest, token, message)     class method This #immK(HttpRequest httpRequest, S token, S message)=(..)
  //imm methods:
  #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
  #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
  norm()                             method This norm()=(..)
  with(httpRequest)                  method This with(HttpRequest httpRequest)=(..)
  with(message)                      method This with(S message)=(..)
  with(token)                        method This with(S token)=(..)
  //read methods:
  httpRequest()                      read method read HttpRequest httpRequest()=(..)
  immClone()                         read method This immClone()=(..)
  message()                          read method S message()=(..)
  readEquality(that)                 read method Bool readEquality(read This that)=(..)
  toS()                              read method S toS()=(..)
  token()                            read method S token()=(..)
  //mut methods:
  #apply(user, repository, path, contentBase64)     mut method Void #apply(S user, S repository, S path, S contentBase64)[Fail]=(..)
  #httpRequest()                     mut method mut HttpRequest #httpRequest()=(..)
  capsuleClone()                     mut method capsule This capsuleClone()=(..)
  write(on, contentBase64)           mut method Void write(Url on, S contentBase64)[Fail]=(..)
  Fail={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()
    text()                             read method S text()
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)
    text(that)                         mut method Void text(S that)
    }
  HttpRequest={
    interface
    #apply(request, body)              mut method Response #apply(S request, S body)[Fail]
    Real={
      [This1]
      //class methods:
      #$of()                             @Public class method mut This #$of()=(..)
      //mut methods:
      #apply(request, body)              @Public mut method Response #apply(S request, S body)[Fail]=(..)
      }
    Response={
      [HasToS]
      //class methods:
      #apply(statusCode, body)           class method This #apply(fwd imm I statusCode, fwd imm S body)=(..)
      #immK(statusCode, body)            class method This #immK(I statusCode, S body)=(..)
      //imm methods:
      #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
      #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
      norm()                             method This norm()=(..)
      with(body)                         method This with(S body)=(..)
      with(statusCode)                   method This with(I statusCode)=(..)
      //read methods:
      body()                             read method S body()=(..)
      immClone()                         read method This immClone()=(..)
      readEquality(that)                 read method Bool readEquality(read This that)=(..)
      statusCode()                       read method I statusCode()=(..)
      toS()                              read method S toS()=(..)
      //mut methods:
      capsuleClone()                     mut method capsule This capsuleClone()=(..)
      }
    }
  }
Process={
  interface
  start(input)                       @{
    Capability method
    Starts the process with the provided input.
    It waits until the process is completed.
    returns a @Result.
    Note that a @Fail exception would raise if the process can not start,
    but if the process ends with errors (on the standard error stream),
    they would just be part of the result.
    }mut method Result start(S input)[Fail]
  Fail={
    [Message, HasToS, Message.Guard]
    //class methods:
    #apply(text, cause)                class method mut This #apply(S text, Message.OptMessage cause)
    #apply(that)                       class method mut This #apply(S that)=(..)
    #from(stringLiteral)               class method This #from(S.StringBuilder stringLiteral)=(..)
    //imm methods:
    #whoopsed(atPos)                   method This #whoopsed(Library atPos)=(..)
    with(cause)                        method This with(Message cause)=(..)
    //read methods:
    cause()                            read method Message.OptMessage cause()
    text()                             read method S text()
    toS()                              read method S toS()=(..)
    //mut methods:
    cause(that)                        mut method Void cause(Message.OptMessage that)
    text(that)                         mut method Void text(S that)
    }
  Real={
    [This1]
    //class methods:
    #$of(that)                         @{
      Capability factory
      Makes a @This capability object that can only run the provided process
      with the provided parameters    
      }@Public class method mut This #$of(S.List that)=(..)
    //read methods:
    that()                             @{
      The process ready to run
      }@Public read method S.List that()=(..)
    //mut methods:
    start(input)                       @{
      Capability method
      Starts the process with the provided input.
      It waits until the process is completed.
      returns a @Result.
      Note that a @Fail exception would raise if the process can not start,
      but if the process ends with errors (on the standard error stream),
      they would just be part of the result.
      }@Public mut method Result start(S input)[Fail]=(..)
    }
  Result={
    [HasToS]
    //class methods:
    #apply(out, err)                   class method This #apply(fwd imm S out, fwd imm S err)=(..)
    #immK(out, err)                    class method This #immK(S out, S err)=(..)
    //imm methods:
    #bangequal0(that)                  method Bool #bangequal0(This that)=(..)
    #equalequal0(that)                 method Bool #equalequal0(This that)=(..)
    norm()                             method This norm()=(..)
    with(err)                          method This with(S err)=(..)
    with(out)                          method This with(S out)=(..)
    //read methods:
    err()                              @{
      the standard error of the process
      }read method S err()=(..)
    immClone()                         read method This immClone()=(..)
    out()                              @{
      the standard output of the process
      }read method S out()=(..)
    readEquality(that)                 read method Bool readEquality(read This that)=(..)
    toS()                              read method S toS()=(..)
    //mut methods:
    capsuleClone()                     mut method capsule This capsuleClone()=(..)
    }
  }
]]></pre>
        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'>
            <a href="mailto:marco.servetto@gmail.com" rel="me">Contact Us</a> |</li>
            <li style='display:inline;'>
            <a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>


